{"version":3,"sources":["Navigation/NavigationSection.js","Navigation/Navigation.js","Element/Element.js","Array/Array.js","Array/ArrayInformation.js","List/List.js","List/ListInformation.js","ArrayList/ArrayList.js","ArrayList/ArrayListInformation.js","LinkedList/LinkedList.js","LinkedList/LinkedListInformation.js","Stack/Stack.js","Stack/StackInformation.js","Queue/Queue.js","Queue/QueueInformation.js","BinaryTree/BinaryTreeDisplay.js","BinaryTree/BinaryTree.js","BinaryTree/BinaryTreeInformation.js","BinarySearchTree/BinarySearchTree.js","BinarySearchTree/BinarySearchTreeInformation.js","AvlTree/AvlTree.js","AvlTree/AvlTreeInformation.js","BinaryHeap/BinaryHeap.js","BinaryHeap/BinaryHeapInformation.js","HashTable/HashTable.js","HashTable/HashTableInformation.js","Set/Set.js","Set/SetInformation.js","Map/Map.js","Map/MapInformation.js","InsertionSort/InsertionSort.js","InsertionSort/InsertionSortInformation.js","SelectionSort/SelectionSort.js","SelectionSort/SelectionSortInformation.js","BubbleSort/BubbleSort.js","BubbleSort/BubbleSortInformation.js","MergeSort/MergeSort.js","MergeSort/MergeSortInformation.js","QuickSort/QuickSort.js","QuickSort/QuickSortInformation.js","HeapSort/HeapSort.js","HeapSort/HeapSortInformation.js","LinearSearch/LinearSearch.js","LinearSearch/LinearSearchInformation.js","BinarySearch/BinarySearch.js","BinarySearch/BinarySearchInformation.js","DepthFirstSearch/DepthFirstSearch.js","DepthFirstSearch/DepthFirstSearchInformation.js","BreadthFirstSearch/BreadthFirstSearch.js","BreadthFirstSearch/BreadthFirstSearchInformation.js","App.js","index.js"],"names":["NavigationList","props","list","map","value","index","to","NavigationSection","useState","dropDown","setDropDown","toggleDropDown","prevDropDown","title","onClick","Navigation","className","Element","color","border","ArrayDisplay","array","Array","setArray","forceRender","randomSize","useRef","arraySize","setIndex","setValue","deleteIndex","arrayOutput","getIndex","forceUpdate","renders","randomArray","size","current","randInt","isNaN","parseInt","newArray","i","push","min","max","Math","floor","random","useEffect","id","ref","type","length","data","readOnly","ArrayInformation","ListDisplay","List","setList","insertIndex","insertValue","removeIndex","listOutput","randomList","newList","splice","ListInformation","ArrayList","ArrayListInformation","Node","this","next","LinkedListClass","head","previous","newNode","curr","prev","LinkedListDisplay","componentList","focus","green","yellow","pink","LinkedList","speedSlider","interval","animationFunction","animationValue","targetIndex","animating","currentNode","currentIndex","toggleAnimation","insertAt","useCallback","clearInterval","setInterval","insertStep","getStep","get","removeStep","remove","onChange","LinkedListInformation","StackDisplay","stack","Stack","setStack","stackInput","stackOutput","randomStack","newStack","pop","undefined","StackInformation","QueueClass","tail","temp","QueueDisplay","queue","Queue","setQueue","queueInput","queueOutput","randomQueue","newQueue","enqueue","dequeue","peek","QueueInformation","BinaryTreeLevel","node","BinaryTreeLineLevel","lines","BinaryTreeDisplay","levelComponents","nextQueue","tree","root","currQueue","left","right","allNull","BinaryTreeNode","BinaryTreeClass","BinaryTree","setTree","randomTree","levels","newTree","nodes","newNodes","level","pow","BinaryTreeInformation","BinarySearchTreeClass","height","parent","leftmostChild","BinarySearchTree","insertInput","removeInput","findInput","insert","findStep","BinarySearchTreeInformation","getParent","cur","console","log","getHeight","getBalance","rotateRight","newRoot","T2","rotateLeft","getLeftmost","leftmost","getRightMost","rightmost","AvlTreeClass","inOrder","sortedArrayToAVL","arr","start","end","mid","AvlTree","secondRot","familyLine","status","treeList","n","rotateStep","rightTree","rotateStepDelete","family","z","abs","y","x","firstUnbalanced","l","grandP","indexOf","r","AvlTreeInformation","BinaryHeapClass","heap","focusNode","greenNode","pinkNode","returnValue","indices","newIndices","BinaryHeap","setHeap","animationCurrent","randomHeap","elements","newHeap","getTree","BinaryHeapInformation","HashTableClass","loadFactor","LOADFACTOR","oldArray","resize","hashCode","hash","HashTableDisplay","hashTable","HashTable","setHashTable","randomLF","buildSize","buildLF","lastInserted","lastRemoved","lastFound","randomHashTable","parseFloat","newHashTable","find","toFixed","HashTableInformation","SetDisplay","concat","set","MySet","Set","setSet","findOutput","randomSet","newSet","add","delete","has","SetInformation","MapDisplay","forEach","key","MyMap","Map","setMap","insertKey","removeKey","getKey","getOutput","randomMap","newMap","readonly","MapInformation","InsertionSortDisplay","currentCompare","currentInserting","sortedEndIndex","InsertionSort","sorted","setSorted","sorting","toggleSortingButton","generateArrayButton","arraySizeInput","sortingStep","toggleSorting","innerHTML","classList","InsertionSortInformation","SelectionSortDisplay","currentMinimum","currentFocus","SelectionSort","SelectionSortInformation","BubbleSortDisplay","sortedStart","focusOne","focusTwo","BubbleSort","swappedOnPass","swap","BubbleSortInformation","MergeSortDisplay","mergedArrays","array1","arrays","array2","mergedArray","MergeSortDisplayRow","MergeSortDisplayRowHelper1","MergeSortDisplayRowHelper2","MergeSort","mergedArraysCurrs","mergeRowIndex","randomArrays","newArrays","initializeMergedArrays","ceil","j","MergeSortInformation","QuickSortDisplay","pivot","low","high","sortedElements","includes","QuickSort","worklist","shift","toInsert","filter","buildSorted","QuickSortInformation","SortedArrayDisplay","HeapSort","sortedArray","setSortedArray","HeapSortInformation","LinearSearch","searchInput","searching","searchValue","searchingStep","LinearSearchInformation","upper","lower","BinarySearch","sort","BinarySearchInformation","DepthFirstSearch","nodeQueue","dfs","DepthFirstSearchInformation","BreadthFirstSearch","bfs","BreadthFirstSearchInformation","App","exact","path","src","alt","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.199438ca.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport { Link } from 'react-router-dom';\r\n\r\nconst NavigationList = (props) => {\r\n    return props.list.map((value, index) => {\r\n        return <li key={index}><Link to={\"/\"+value}>{value}</Link></li>\r\n    });\r\n}\r\n\r\nconst NavigationSection = (props) => {\r\n    \r\n    const [dropDown, setDropDown] = useState(true);\r\n\r\n    const toggleDropDown = () => {\r\n        setDropDown(prevDropDown => !prevDropDown);\r\n    }\r\n\r\n    if(dropDown) {\r\n        return (\r\n            <>\r\n                <p>{props.title}</p>\r\n                <button onClick={toggleDropDown}>&#x25BC;</button>\r\n                <ul>\r\n                    <NavigationList list={props.list} />\r\n                </ul>\r\n            </>\r\n        );\r\n    } else {\r\n        return (\r\n            <>\r\n                <p>{props.title}</p>\r\n                <button onClick={toggleDropDown}>&#x25B2;</button>\r\n            </>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default NavigationSection","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport './Navigation.scss';\r\nimport NavigationSection from './NavigationSection';\r\n\r\nconst Navigation = () => {\r\n\r\n    return (\r\n        <div className=\"navigation\">\r\n            <ul>\r\n                <li><Link to=\"/\">Home</Link></li>\r\n                <li><NavigationSection title={\"Data Structures\"} list={[\"Array\", \"List\", \"Array List\", \"Linked List\", \"Stack\", \"Queue\", \"Binary Tree\", \"Binary Search Tree\", \"AVL Tree\", \"Binary Heap\", \"Hash Table\", \"Set\", \"Map\"]} /></li>\r\n                <li><NavigationSection title={\"Algorithms\"} list={[\"Insertion Sort\", \"Selection Sort\", \"Bubble Sort\", \"Merge Sort\", \"Quick Sort\", \"Heap Sort\", \"Linear Search\", \"Binary Search\", \"Depth First Search\", \"Breadth First Search\"]} /></li>\r\n                <li><Link to=\"/about\">About Us</Link></li>\r\n            </ul>\r\n        </div>\r\n    );\r\n    \r\n}\r\n\r\nexport default Navigation","import React from 'react';\r\nimport './Element.scss';\r\n\r\nconst Element = (props) => {\r\n\treturn <p className={\"element \" + props.color + \" \" + props.border}>{props.value}</p>;\r\n}\r\n\r\nexport default Element;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Array.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst ArrayDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        return (\r\n            <div key={index} className=\"labeledElement\">\r\n                <label>{index}</label>\r\n                <Element value={value}></Element>\r\n            </div>\r\n        );\r\n    });\r\n}\r\n\r\nconst Array = () => {\r\n    const [array, setArray] = useState([]);\r\n    const [, forceRender] = useState(0);\r\n    const randomSize = useRef();\r\n    const arraySize = useRef();\r\n    const setIndex = useRef();\r\n    const setValue = useRef();\r\n    const deleteIndex = useRef();\r\n    const arrayOutput = useRef();\r\n    const getIndex = useRef();\r\n\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //sets array to a randomly generated array\r\n    const randomArray = () => {\r\n        var size = randomSize.current.value;\r\n        if (size === \"\") {\r\n            size = randInt(10, 60);\r\n        }\r\n        if (!isNaN(parseInt(size)) && size > 0) {\r\n            var newArray = [];\r\n            for (let i = 0; i < size; i++)\r\n                newArray.push(randInt(-999,1000));\r\n            setArray(newArray);\r\n        }\r\n        randomSize.current.value = null;\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize list to random list\r\n    useEffect(randomArray, []);\r\n\r\n    const build = () => {\r\n        var newArray = [];\r\n            var size = parseInt(arraySize.current.value);\r\n            if(isNaN(size))\r\n                size = randInt(10, 60);\r\n            while (size > 0) {\r\n                newArray.push(null);\r\n                size--;\r\n        }\r\n        setArray(newArray);\r\n        arraySize.current.value = null;\r\n    }\r\n\r\n    const set = () => {\r\n        const index = parseInt(setIndex.current.value);\r\n        const value = parseInt(setValue.current.value);\r\n        if (!isNaN(index) && !isNaN(value) && index >= 0 && index < array.length) {\r\n            array[index] = value;\r\n            forceUpdate();\r\n        } else {\r\n            arrayOutput.current.value = \"Invalid\";\r\n        }\r\n        setIndex.current.value = null;\r\n        setValue.current.value = null;\r\n    }\r\n\r\n    const remove = () => {\r\n        const index = parseInt(deleteIndex.current.value);\r\n        if (!isNaN(index) && index >= 0 && index < array.length) {\r\n            const data = array[index];\r\n            arrayOutput.current.value = data;\r\n            if (array[index] == null) {\r\n                arrayOutput.current.value = \"Invalid\";\r\n            }\r\n            array[index] = null;\r\n            \r\n            forceUpdate();\r\n            \r\n        }\r\n        \r\n        else {\r\n            arrayOutput.current.value = \"Invalid\";\r\n        }\r\n        deleteIndex.current.value = null;\r\n    }\r\n\r\n    const get = () => {\r\n        const index = parseInt(getIndex.current.value);\r\n        if (!isNaN(index) && index >= 0 && index < array.length) {\r\n            const data = array[index];\r\n            arrayOutput.current.value = data;\r\n            if (array[index] == null) {\r\n                arrayOutput.current.value = \"null\";\r\n            }\r\n        } else {\r\n            arrayOutput.current.value = \"Invalid\";\r\n        }\r\n        getIndex.current.value = null;\r\n    }\r\n\r\n\r\n    return (\r\n        <div className=\"array\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomArray}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Size</label>\r\n                    <input id=\"randomSizeInput\" ref={randomSize} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"buildButton\" onClick={build}>Build</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Size</label>\r\n                    <input type=\"text\" ref={arraySize}></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"setButton\" onClick={set}>Set</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"setIndex\" type=\"text\" ref={setIndex}></input>\r\n                </span>\r\n                <span className=\"labeledInput\">\r\n                    <label>Value</label>\r\n                    <input id=\"setValue\" type=\"text\" ref={setValue}></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"deleteButton\" onClick={remove}>Delete</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input type=\"text\" ref={deleteIndex}></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"getButton\" onClick={get}>Get</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input type=\"text\" ref={getIndex}></input>\r\n                </span>\r\n                \r\n                <br />\r\n                <input id=\"arrayOutput\" type=\"text\" ref={arrayOutput} readOnly></input>\r\n                <br />\r\n                \r\n            </div>\r\n            <div className=\"visualization\">\r\n                <ArrayDisplay array={array} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Array;","import React from 'react';\r\n\r\nconst ArrayInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>An array is a linear data structure where elements are stored in a contiguous block of memory. Each element typically takes up the same amount of space in memory so that the location of an element can be easily computed from its index. To find the location of the element in memory, the index is multiplied by the size of an element and then added to the base address of the array.</p>\r\n            <br />\r\n            <p><u>An Array has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Build:</b> initializes an array of a certain size by allocating space in memory</li>\r\n                <li><b>Set:</b> sets the value of an element at a specific index in the array</li>\r\n                <li><b>Delete:</b> removes an element at a specific index in the array</li>\r\n                <li><b>Get:</b> returns the value of an element at a specific index in the array</li>\r\n            </ul>\r\n            <br />\r\n            <p>Because an array allows for finding the location of an element in memory in constant time, operations like set, delete, and get can all be done in constant time. However, some more complex operations such as insertion and deletion from a full array require copying several elements to new locations in memory, and therefore take linear time.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Complexity</th></tr>\r\n                    <tr><td>Build</td><td>O(1)</td></tr>\r\n                    <tr><td>Set</td><td>O(1)</td></tr>\r\n                    <tr><td>Delete</td><td>O(1)</td></tr>\r\n                    <tr><td>Get</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ArrayInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './List.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst ListDisplay = (props) => {\r\n    return props.list.map((value, index) => {\r\n        return (\r\n            <div key={index} className=\"labeledElement\">\r\n                <label>{index}</label>\r\n                <Element value={value}></Element>\r\n            </div>\r\n        );\r\n    });\r\n}\r\n\r\n//main react component for list\r\nconst List = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [list, setList] = useState([]);\r\n    const randomSize = useRef();\r\n    const insertIndex = useRef();\r\n    const insertValue = useRef();\r\n    const removeIndex = useRef();\r\n    const listOutput = useRef();\r\n    const getIndex = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets list to a randomly generated list\r\n    const randomList = () => {\r\n        var size = randomSize.current.value;\r\n        if (size === \"\") {\r\n            size = randInt(10, 60);\r\n        }\r\n        if (!isNaN(parseInt(size)) && size > 0) {\r\n            var newList = [];\r\n            for (let i = 0; i < size; i++)\r\n                newList.push(randInt(-999,1000));\r\n            setList(newList);\r\n        }\r\n        randomSize.current.value = null;\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize list to random list\r\n    useEffect(randomList, []);\r\n\r\n    const insert = () => {\r\n        var index = parseInt(insertIndex.current.value);\r\n        var value = parseInt(insertValue.current.value);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if(isNaN(value))\r\n            value = 0;\r\n        if (index >= 0 && index <= list.length) {\r\n            list.splice(index, 0, value);\r\n            forceUpdate();\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        insertIndex.current.value = null;\r\n        insertValue.current.value = null;\r\n    }\r\n\r\n    const remove = () => {\r\n        var index = parseInt(removeIndex.current.value);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.length) {\r\n            const data = list.splice(index, 1);\r\n            forceUpdate();\r\n            listOutput.current.value = data;\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        removeIndex.current.value = null;\r\n    }\r\n\r\n    const get = () => {\r\n        var index = parseInt(getIndex.current.value);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.length) {\r\n            const data = list[index];\r\n            listOutput.current.value = data;\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        getIndex.current.value = null;\r\n    }\r\n\r\n    return (\r\n        <div className=\"list\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomList}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Size</label>\r\n                    <input id=\"randomSizeInput\" ref={randomSize} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"insertIndex\" ref={insertIndex} type=\"text\"></input>\r\n                </span>\r\n                <span className=\"labeledInput\">\r\n                    <label>Value</label>\r\n                    <input id=\"insertValue\" ref={insertValue} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"removeIndex\" ref={removeIndex} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <input id=\"listOutput\" type=\"text\" ref={listOutput} readOnly></input>\r\n                <br />\r\n                <button id=\"getButton\" onClick={get}>Get</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"getIndex\" ref={getIndex} type=\"text\"></input>\r\n                </span>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <ListDisplay list={list} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default List;","import React from 'react';\r\n\r\nconst ListInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A list is an Abstract Data Type (ADT) that represents data in a linear structure. Elements can be added or removed at any point in the list. The list maintains a specific order depending on where in the list elements were inserted and removed.</p>\r\n            <br />\r\n            <p><u>A list includes the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into the list at a specific index</li>\r\n                <li><b>Remove:</b> removes an element from the list at a specific index</li>\r\n                <li><b>Get:</b> returns an element from the list at a specific index without removing it</li>\r\n            </ul>\r\n            <br />\r\n            <p><u>Since a List is an ADT, it has multiple possible implementations:</u></p>\r\n            <ul>\r\n                <li><b>Array List:</b> Elements are kept in an contiguous piece of memory in an array form. The benefit of this is its simplicity and relatively lower memory usage. Another benefit is the ability to reach an element at a given index in constant time. The cons of this implementation are that it has a limitted capacity and may need to copy all of its values to a new array to increase the capacity. Also, it takes linear time to insert or remove an element.</li>\r\n                <li><b>Linked List:</b> Each element is kept with a pointer to the next element in the list. A pointer is kept for the first element in the list. The advantage of this is that it can dynamically resize at runtime and takes only as much memory as is needed. It also allows constant time removal or addition to the head, or any other place in the list if it has a pointer to that spot. A disadvantage of linked list is the greater memory cost to store values and pointers to the next node. Also, reaching an element at a given index takes linear time.</li>\r\n            </ul>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th></th><th>Array List</th><th>Linked List</th></tr>\r\n                    <tr><th>Insert at head</th><td>O(n)</td><td><b>O(1)</b></td></tr>\r\n                    <tr><th>Remove at head</th><td>O(n)</td><td><b>O(1)</b></td></tr>\r\n                    <tr><th>Get from head</th><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><th>Insert at given index</th><td>O(n)</td><td>O(n)</td></tr>\r\n                    <tr><th>Remove at given index</th><td>O(n)</td><td>O(n)</td></tr>\r\n                    <tr><th>Get from given index</th><td><b>O(1)</b></td><td>O(n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ListInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './ArrayList.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst ListDisplay = (props) => {\r\n    return props.list.map((value, index) => {\r\n        return (\r\n            <div key={index} className=\"labeledElement\">\r\n                <label>{index}</label>\r\n                <Element value={value}></Element>\r\n            </div>\r\n        );\r\n    });\r\n}\r\n\r\n//main react component for list\r\nconst ArrayList = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [list, setList] = useState([]);\r\n    const randomSize = useRef();\r\n    const insertIndex = useRef();\r\n    const insertValue = useRef();\r\n    const removeIndex = useRef();\r\n    const listOutput = useRef();\r\n    const getIndex = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //sets list to a randomly generated list\r\n    const randomList = () => {\r\n        var size = randomSize.current.value;\r\n        if (size === \"\") {\r\n            size = randInt(10, 60);\r\n        }\r\n        if (!isNaN(parseInt(size)) && size > 0) {\r\n            var newList = [];\r\n            for (let i = 0; i < size; i++)\r\n                newList.push(randInt(-999, 1000));\r\n            setList(newList);\r\n        }\r\n        randomSize.current.value = null;\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max - min) + min);\r\n    }\r\n\r\n    //initialize list to random list\r\n    useEffect(randomList, []);\r\n\r\n    const insert = () => {\r\n        var index = parseInt(insertIndex.current.value);\r\n        var value = parseInt(insertValue.current.value);\r\n        if (isNaN(index))\r\n            index = 0;\r\n        if (isNaN(value))\r\n            value = 0;\r\n        if (index >= 0 && index <= list.length) {\r\n            list.splice(index, 0, value);\r\n            forceUpdate();\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        insertIndex.current.value = null;\r\n        insertValue.current.value = null;\r\n    }\r\n\r\n    const remove = () => {\r\n        var index = parseInt(removeIndex.current.value);\r\n        if (isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.length) {\r\n            const data = list.splice(index, 1);\r\n            forceUpdate();\r\n            listOutput.current.value = data;\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        removeIndex.current.value = null;\r\n    }\r\n\r\n    const get = () => {\r\n        var index = parseInt(getIndex.current.value);\r\n        if (isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.length) {\r\n            const data = list[index];\r\n            listOutput.current.value = data;\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        getIndex.current.value = null;\r\n    }\r\n\r\n    return (\r\n        <div className=\"array-list\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomList}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Size</label>\r\n                    <input id=\"randomSizeInput\" ref={randomSize} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"insertIndex\" ref={insertIndex} type=\"text\"></input>\r\n                </span>\r\n                <span className=\"labeledInput\">\r\n                    <label>Value</label>\r\n                    <input id=\"insertValue\" ref={insertValue} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"removeIndex\" ref={removeIndex} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <input id=\"listOutput\" type=\"text\" ref={listOutput} readOnly></input>\r\n                <br />\r\n                <button id=\"getButton\" onClick={get}>Get</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"getIndex\" ref={getIndex} type=\"text\"></input>\r\n                </span>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <ListDisplay list={list} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ArrayList;","import React from 'react';\r\n\r\nconst ArrayListInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>An Array List is a linear data structure. Values are stored in an array structure using a contiguous block of memory. An Array List is one possible implementation of a List, an Abstract Data Type (ADT).</p>\r\n            <br />\r\n            <p><u>An Array List has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into the array list at a specific index</li>\r\n                <li><b>Remove:</b> removes an element from the array list at a specific index</li>\r\n                <li><b>Get:</b> returns an element from the array list at a specific index without removing it</li>\r\n            </ul>\r\n            <br />\r\n            <p>Since the information in an array list is stored contiguously in an array, it benefits from random access. Consequently, operations such as accessing an element from a given index are very inexpensive. The trade off for this is that insertion and deletion become expensive operations since they require creating a new array or copying several elements to new locations in memory.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Complexity</th></tr>\r\n                    <tr><td>Insert at head</td><td>O(n)</td></tr>\r\n                    <tr><td>Remove at head</td><td>O(n)</td></tr>\r\n                    <tr><td>Get from head</td><td>O(1)</td></tr>\r\n                    <tr><td>Insert at given index</td><td>O(n)</td></tr>\r\n                    <tr><td>Remove at given index</td><td>O(n)</td></tr>\r\n                    <tr><td>Get from given index</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ArrayListInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './LinkedList.scss';\r\nimport Element from '../Element/Element';\r\n\r\nclass Node {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass LinkedListClass {\r\n    constructor(head = null) {\r\n        this.head = head;\r\n        this.size = 0;\r\n    }\r\n\r\n    //for insertion at tail -- currently unused\r\n    insert(data) {\r\n        if (this.head == null) {\r\n            this.head = new Node(data);\r\n        }\r\n        else {\r\n            var current = this.head;\r\n            while (current.next != null) {\r\n                current = current.next;\r\n            }\r\n            current.next = new Node(data);\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    insertAt(data, index) {\r\n        var newNode = new Node(data);\r\n        var current = this.head;\r\n        var previous;\r\n\r\n        if (index <= this.size) {\r\n\r\n            if (index === 0) {\r\n                newNode.next = this.head;\r\n                this.head = newNode;\r\n            }\r\n            else {\r\n                var i = 0;\r\n                while (i < index) {\r\n                    i++;\r\n                    previous = current;\r\n                    current = current.next;\r\n                }\r\n                newNode.next = current;\r\n                previous.next = newNode;\r\n            }\r\n            this.size++;\r\n        }\r\n    }\r\n\r\n    get(index) {\r\n        var i = 0;\r\n        var current = this.head;\r\n        while (i !== index) {\r\n            current = current.next;\r\n            i++;\r\n        }\r\n        return current.value;\r\n    }\r\n\r\n    remove(index) {\r\n        var i = 0;\r\n        var curr, prev, next;\r\n        if (index < this.size && this.size > 0) {\r\n            if (index === 0) {\r\n                this.head = this.head.next;\r\n                this.size--;\r\n            }\r\n            else {\r\n                i++;\r\n                prev = this.head;\r\n                curr = prev.next;\r\n                next = curr.next;\r\n                while (i !== index) {\r\n                    i++;\r\n                    prev = prev.next;\r\n                    curr = curr.next;\r\n                    next = next.next;\r\n                }\r\n                prev.next = next;\r\n                this.size--;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst LinkedListDisplay = (props) => {\r\n    var current = props.list.head;\r\n    var index = 0;\r\n    var componentList = [];\r\n    while (current != null) {\r\n        if (current === props.focus) {\r\n            componentList.push(\r\n                <div key={2*index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={current.value} border=\"bordered\"></Element>\r\n                </div>\r\n            );\r\n        } else if (current === props.green) {\r\n            componentList.push(\r\n                <div key={2*index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={current.value} color=\"green\"></Element>\r\n                </div>\r\n            );\r\n        } else if (current === props.yellow) {\r\n            componentList.push(\r\n                <div key={2*index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={current.value} color=\"yellow\"></Element>\r\n                </div>\r\n            );\r\n        } else if (current === props.pink) {\r\n            componentList.push(\r\n                <div key={2*index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={current.value} color=\"pink\"></Element>\r\n                </div>\r\n            );\r\n        } else {\r\n            componentList.push(\r\n                <div key={2*index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={current.value}></Element>\r\n                </div>\r\n            );\r\n        }\r\n        componentList.push(\r\n            <p className=\"arrow\" key={2*index+1}>&#x2192;</p>\r\n        );\r\n        current = current.next;\r\n        index++;\r\n    }\r\n    componentList.push(<Element key={2*index} value=\"null\" />);\r\n    return componentList;\r\n\r\n    \r\n}\r\n\r\nconst LinkedList = () => {\r\n\r\n    const [list, setList] = useState(new LinkedListClass());\r\n    const [, forceRender] = useState(0);\r\n    const randomSize = useRef();\r\n    const insertIndex = useRef();\r\n    const insertValue = useRef();\r\n    const removeIndex = useRef();\r\n    const listOutput = useRef();\r\n    const getIndex = useRef();\r\n    const speedSlider = useRef();\r\n    const interval = useRef();\r\n    const animationFunction = useRef();\r\n    const animationValue = useRef();\r\n    const targetIndex = useRef();\r\n    const animating = useRef();\r\n    const currentNode = useRef();\r\n    const currentIndex = useRef();\r\n    const green = useRef();\r\n    const yellow = useRef(null);\r\n    const pink = useRef(null);\r\n\r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //sets list to a randomly generated list\r\n    const randomList = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var size = randomSize.current.value;\r\n        if (size === \"\") {\r\n            size = randInt(8, 40);\r\n        }\r\n        if (!isNaN(parseInt(size)) && size > 0) {\r\n            var newList = new LinkedListClass();\r\n            for (let i = 0; i < size; i++)\r\n                newList.insertAt(randInt(-999,1000), 0);\r\n            setList(newList);\r\n        }\r\n        randomSize.current.value = null;\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //function to pause or continue animation\r\n    const toggleAnimation = useCallback(() => {\r\n        if (animating.current) {\r\n            clearInterval(interval.current);\r\n            animating.current = false;\r\n            animationFunction.current = null;\r\n            animationValue.current = null;\r\n            targetIndex.current = null;\r\n            currentNode.current = null;\r\n            currentIndex.current = null;\r\n            pink.current = null;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            animating.current = true;\r\n            green.current = null;\r\n            yellow.current = null;\r\n        }\r\n    }, []);\r\n\r\n    //initialize list to random list\r\n    useEffect(randomList, [toggleAnimation]);\r\n\r\n    //insertion only occurs at head for now\r\n    function insert() {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var data = parseInt(insertValue.current.value);\r\n        var index = parseInt(insertIndex.current.value);\r\n        if(isNaN(data))\r\n            data = randInt(-999,1000);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if (index === 0) {\r\n            list.insertAt(data, 0);\r\n            green.current = list.head;\r\n            yellow.current = null;\r\n            forceUpdate();\r\n        } else if (index > 0 && index < list.size) {\r\n            animationFunction.current = insertStep;\r\n            animationValue.current = data;\r\n            targetIndex.current = index;\r\n            currentNode.current = list.head;\r\n            currentIndex.current = 0;\r\n            forceUpdate();\r\n            toggleAnimation();\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        insertValue.current.value = null;\r\n        insertIndex.current.value = null;\r\n    }\r\n\r\n    //function for a single step of insertion animation\r\n    const insertStep = () => {\r\n        if(currentIndex.current === targetIndex.current-1) {\r\n            list.insertAt(animationValue.current, targetIndex.current);\r\n            green.current = currentNode.current.next;\r\n            toggleAnimation();\r\n        } else {\r\n            currentNode.current = currentNode.current.next;\r\n            currentIndex.current++;\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var index = parseInt(getIndex.current.value);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.size) {\r\n            animationFunction.current = getStep;\r\n            targetIndex.current = index;\r\n            currentIndex.current = 0;\r\n            currentNode.current = list.head;\r\n            forceUpdate();\r\n            toggleAnimation();\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        getIndex.current.value = null;\r\n    }\r\n\r\n    //function for a single step of get animation\r\n    const getStep = () => {\r\n        if (targetIndex.current === currentIndex.current) {\r\n            if (yellow.current === null) {\r\n                yellow.current = currentNode.current;\r\n                currentNode.current = null;\r\n            } else {\r\n                listOutput.current.value = list.get(targetIndex.current);\r\n                toggleAnimation();\r\n            }\r\n        } else {\r\n            currentNode.current = currentNode.current.next;\r\n            currentIndex.current++;\r\n        }\r\n    }\r\n\r\n    function remove() {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var index = parseInt(removeIndex.current.value);\r\n        if(isNaN(index))\r\n            index = 0;\r\n        if (index >= 0 && index < list.size) {\r\n            animationFunction.current = removeStep;\r\n            targetIndex.current = index;\r\n            currentIndex.current = 0;\r\n            currentNode.current = list.head;\r\n            forceUpdate();\r\n            toggleAnimation();\r\n        } else {\r\n            listOutput.current.value = \"Invalid\";\r\n        }\r\n        removeIndex.current.value = null;\r\n    }\r\n\r\n    //function to do 1 step of remove animation\r\n    const removeStep = () => {\r\n        if (targetIndex.current === currentIndex.current) {\r\n            if (pink.current === null) {\r\n                pink.current = currentNode.current;\r\n                currentNode.current = null;\r\n            } else {\r\n                listOutput.current.value = list.get(targetIndex.current);\r\n                list.remove(targetIndex.current);\r\n                toggleAnimation();\r\n            }\r\n        } else {\r\n            currentNode.current = currentNode.current.next;\r\n            currentIndex.current++;\r\n        }\r\n    }\r\n\r\n    //changes the animation speed when the slider changes\r\n    const updateSpeed = () => {\r\n        if (animationFunction.current != null) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"linked-list\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomList}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Size</label>\r\n                    <input id=\"randomSizeInput\" ref={randomSize} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"insertIndex\" ref={insertIndex} type=\"text\"></input>\r\n                </span>\r\n                <span className=\"labeledInput\">\r\n                    <label>Value</label>\r\n                    <input id=\"insertValue\" ref={insertValue} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button onClick={remove} id=\"removeButton\" >Remove</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"removeIndex\" ref={removeIndex} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <input id=\"listOutput\" type=\"text\" ref={listOutput} readOnly></input>\r\n                <br />\r\n                <button id=\"getButton\" onClick={get} >Get</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Index</label>\r\n                    <input id=\"getIndex\" ref={getIndex} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <span className=\"labeledSlider\">\r\n                    <label>Animation Speed</label>\r\n                    <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                </span>\r\n            </div>\r\n\r\n            <div className=\"visualization\">\r\n                <LinkedListDisplay list={list} focus={currentNode.current} green={green.current} yellow={yellow.current} pink={pink.current} />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default LinkedList;","import React from 'react';\r\n\r\nconst LinkedListInformation = () => {\r\n\treturn (\r\n\t\t<div className=\"information\">\r\n\t\t\t<p>A Linked List is a linear data structure consisting of several nodes. Each node contains an element value, and a pointer to the next node's location in memory. The last node in the list will have a pointer to null. A pointer to the head of the list is always kept track of. A Linked List is one possible implementation of a List, an Abstract Data Type (ADT).</p>\r\n\t\t\t<br />\r\n\t\t\t<p><u>A linked list includes the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into the list at a specific index</li>\r\n                <li><b>Remove:</b> removes an element from the list at a specific index</li>\r\n                <li><b>Get:</b> returns an element from the list at a specific index without removing it</li>\r\n            </ul>\r\n            <br />\r\n\t\t\t<p>The nodes in a Linked List do not need to be stored in contiguous memory. Because of this, it benefits from the ability to insert and delete elements at any point in the list without restructuring or reallocating data in memory. However, one prominent trade off for these benefits is the lack of random access. This causes basic operations, such as obtaining an element by a given index or locating a point of insertion/deletion, to require iterating over the data structure.</p>\r\n\t\t\t<br />\r\n\t\t\t<table>\r\n\t\t\t\t<tbody>\r\n\t\t\t\t\t<tr><th>Operation</th><th>Complexity</th></tr>\r\n\t\t\t\t\t<tr><td>Insert at head</td><td>O(1)</td></tr>\r\n\t\t\t\t\t<tr><td>Remove at head</td><td>O(1)</td></tr>\r\n\t\t\t\t\t<tr><td>Get from head</td><td>O(1)</td></tr>\r\n\t\t\t\t\t<tr><td>Insert at given index</td><td>O(n)</td></tr>\r\n\t\t\t\t\t<tr><td>Remove at given index</td><td>O(n)</td></tr>\r\n\t\t\t\t\t<tr><td>Get from given index</td><td>O(n)</td></tr>\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\r\n\t\t</div>\r\n\t\t//TODO add more \r\n\t);\r\n}\r\n\r\nexport default LinkedListInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Stack.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//returns a list of react element components from the stack component array\r\nconst StackDisplay = (props) => {\r\n\treturn props.stack.map((value, index) => {\r\n\t\treturn <Element key={index} value={value} />\r\n\t});\r\n}\r\n\r\n//main react component for stack\r\nconst Stack = () => {\r\n\t\r\n\tconst [, forceRender] = useState(0);\r\n\tconst [stack, setStack] = useState([]);\r\n\tconst stackInput = useRef();\r\n\tconst stackOutput = useRef();\r\n\t\r\n\t//We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n\t//sets queue to a randomly generated queue\r\n    const randomStack = () => {\r\n        const size = randInt(10, 60);\r\n        var newStack = [];\r\n        for (let i = 0; i < size; i++)\r\n            newStack.push(randInt(-999,1000));\r\n        setStack(newStack);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize stack to random stack\r\n    useEffect(randomStack, []);\r\n\t\r\n\tconst push = () => {\r\n\t\tvar data = parseInt(stackInput.current.value);\r\n\t\tif(isNaN(data))\r\n            data = 0;\r\n\t\tstack.push(data);\r\n\t\tforceUpdate();\r\n\t\tstackInput.current.value = null;\r\n\t}\r\n\t\r\n\tconst pop = () => {\r\n\t\tconst data = stack.pop();\r\n\t\tforceUpdate();\r\n\t\tif (data === undefined)\r\n\t\t\tstackOutput.current.value = \"None\";\r\n\t\telse\r\n\t\t\tstackOutput.current.value = data;\r\n\t}\r\n\t\r\n\tconst peek = () => {\r\n\t\tconst data = stack[stack.length-1];\r\n\t\tif (data === undefined)\r\n\t\t\tstackOutput.current.value = \"None\";\r\n\t\telse\r\n\t\t\tstackOutput.current.value = data;\r\n\t}\r\n\t\r\n\treturn (\r\n\t\t<div className=\"stack\">\r\n\t\t\t<div className=\"controls\">\r\n\t\t\t\t<button id=\"randomButton\" onClick={randomStack}>Random</button>\r\n                <br />\r\n\t\t\t\t<button id=\"pushButton\" onClick={push}>Push</button>\r\n\t\t\t\t<input id=\"stackInput\" ref={stackInput} type=\"text\" />\r\n\t\t\t\t<br />\r\n\t\t\t\t<button id=\"popButton\" onClick={pop}>Pop</button>\r\n\t\t\t\t<br />\r\n\t\t\t\t<input id=\"stackOutput\" ref={stackOutput} type=\"text\" readOnly />\r\n\t\t\t\t<br />\r\n\t\t\t\t<button id=\"peekButton\" onClick={peek}>Peek</button>\r\n\t\t\t\t<br />\r\n\t\t\t</div>\r\n\t\t\t<div className=\"visualization\">\r\n\t\t\t\t<StackDisplay stack={stack} />\r\n\t\t\t\t<div id=\"stackTop\">\r\n\t\t\t\t\t<p>&#x2190; Push</p>\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<p>&#x2192; Pop</p>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Stack;","import React from 'react';\r\n\r\nconst StackInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A stack is an Abstract Data Type (ADT) that represents a linear data structure. Elements are stored in a sequential order depending on when they are added to the stack. Elements may only be added or removed from one end of the stack. Therefore a stack is a last-in-first-out (LIFO) data structure. When an element is removed from the stack, it must be the last element that was added onto the end. Likewise, the last element to be removed before the stack is empty would be the first element that was inserted.</p>\r\n            <br />\r\n            <p><u>A stack has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Push:</b> adds an element at the end of the stack</li>\r\n                <li><b>Pop:</b> removes an element from the end of the stack</li>\r\n                <li><b>Peek:</b> returns the element at the end of the stack without removing it</li>\r\n            </ul>\r\n            <br />\r\n            <p><u>Since a stack is an ADT, it has multiple possible implementations:</u></p>\r\n            <ul>\r\n                <li><b>Array Implementation:</b> An array is allocated with a certain capacity to represent the stack. The index of the current top of the stack is kept track of. The advantages of this implementation are its simplicity and relatively low memory usage. The main disadvantage is that the size of the array cannot change so there is a limit to how much data can be stored. On the other hand, the space allocated may be way more than needed.</li>\r\n                <li><b>Linked List Implementation:</b> A linked list is created to represent the stack. Elements are added and removed from the head of the linked last. The advantage of this implementation is its ability to be resized at runtime, therefore only using as much memory as is needed. The disadvantage of this is that the pointers involved in linked lists use more memory than a simple array.</li>\r\n            </ul>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th></th><th>Array Implementation</th><th>Linked List Implementation</th></tr>\r\n                    <tr><th>Push</th><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><th>Pop</th><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><th>Peek</th><td>O(1)</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default StackInformation","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Queue.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//define Queue Node class\r\nclass Node {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\n//define Queue class with linked list implementation\r\nclass QueueClass {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n    enqueue (data) {\r\n        if (this.head == null) {\r\n            this.tail = new Node(data);\r\n            this.head = this.tail;\r\n        } else {\r\n            this.tail.next = new Node(data);\r\n            this.tail = this.tail.next;\r\n        }\r\n    }\r\n    dequeue () {\r\n        if (this.head == null) {\r\n            return undefined;\r\n        } else {\r\n            const temp = this.head;\r\n            this.head = this.head.next;\r\n            if (this.head == null)\r\n                this.tail = null;\r\n            return temp.value;\r\n        }\r\n    }\r\n    peek () {\r\n        if (this.head == null) {\r\n            return undefined;\r\n        } else {\r\n            return this.head.value;\r\n        }\r\n    }\r\n}\r\n\r\n//returns a list of react element components from the queue component linked list\r\nconst QueueDisplay = (props) => {\r\n\tvar current = props.queue.head;\r\n    var index = 0;\r\n    var componentList = [];\r\n    while(current != null) {\r\n        componentList.push(<Element key={index} value={current.value} />);\r\n        current = current.next;\r\n        index++;\r\n    }\r\n    return componentList;\r\n}\r\n\r\n//main react component for queue\r\nconst Queue = () => {\r\n\t\r\n\tconst [, forceRender] = useState(0);\r\n\tconst [queue, setQueue] = useState(new QueueClass());\r\n\tconst queueInput = useRef();\r\n\tconst queueOutput = useRef();\r\n\t\r\n\t//We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\t\r\n\t//sets queue to a randomly generated queue\r\n    const randomQueue = () => {\r\n        const size = randInt(10, 60);\r\n        var newQueue = new QueueClass();\r\n        for (let i = 0; i < size; i++)\r\n            newQueue.enqueue(randInt(-999,1000));\r\n        setQueue(newQueue);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize queue to random queue\r\n    useEffect(randomQueue, []);\r\n\r\n\tconst enqueue = () => {\r\n\t\tvar data = parseInt(queueInput.current.value);\r\n        if(isNaN(data))\r\n            data = 0;\r\n\t\tqueue.enqueue(data);\r\n\t\tforceUpdate();\r\n\t\tqueueInput.current.value = null;\r\n\t}\r\n\t\r\n\tconst dequeue = () => {\r\n\t\tconst data = queue.dequeue();\r\n\t\tforceUpdate();\r\n\t\tif (data === undefined)\r\n\t\t\tqueueOutput.current.value = \"None\";\r\n\t\telse\r\n\t\t\tqueueOutput.current.value = data;\r\n\t}\r\n\t\r\n\tconst peek = () => {\r\n\t\tconst data = queue.peek();\r\n\t\tif (data === undefined)\r\n\t\t\tqueueOutput.current.value = \"None\";\r\n\t\telse\r\n\t\t\tqueueOutput.current.value = data;\r\n\t}\r\n\t\r\n\treturn (\r\n\t\t<div className=\"queue\">\r\n\t\t\t<div className=\"controls\">\r\n\t\t\t\t<button id=\"randomButton\" onClick={randomQueue}>Random</button>\r\n                <br />\r\n\t\t\t\t<button id=\"enqueueButton\" onClick={enqueue}>Enqueue</button>\r\n\t\t\t\t<input id=\"queueInput\" ref={queueInput} type=\"text\" />\r\n\t\t\t\t<br />\r\n\t\t\t\t<button id=\"dequeueButton\" onClick={dequeue}>Dequeue</button>\r\n\t\t\t\t<br />\r\n\t\t\t\t<input id=\"queueOutput\" ref={queueOutput} type=\"text\" readOnly />\r\n\t\t\t\t<br />\r\n\t\t\t\t<button id=\"peekButton\" onClick={peek}>Peek</button>\r\n\t\t\t\t<br />\r\n\t\t\t</div>\r\n\t\t\t<div className=\"visualization\">\r\n\t\t\t\t<div className=\"queueEnd\">\r\n                <p>Dequeue &#x2190;</p>\r\n                </div>\r\n                <QueueDisplay queue={queue} />\r\n\t\t\t\t<div className=\"queueEnd\">\r\n\t\t\t\t\t<p>&#x2190; Enqueue</p>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Queue;","import React from 'react';\r\n\r\nconst QueueInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A queue is an Abstract Data Type (ADT) that represents a linear data structure. Elements may only be added to one end and removed from the other end of a queue. Therefore a queue is a first-in-first-out (FIFO) data structure. When an element is removed from the queue, it will be the earliest one added. The last element to be removed will be the last one added to the queue.</p>\r\n            <br />\r\n            <p><u>A queue has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Enqueue:</b> adds an element to the queue</li>\r\n                <li><b>Dequeue:</b> removes an element from the queue</li>\r\n                <li><b>Peek:</b> returns the next element to be removed from the queue without removing it</li>\r\n            </ul>\r\n            <br />\r\n            <p><u>Since a queue is an ADT, it has multiple possible implementations:</u></p>\r\n            <ul>\r\n                <li><b>Linked List Implementation:</b> A linked list is created to represent the queue. Elements are enqueued at the tail of the linked list and dequeued at the head. A pointer is kept for both the head and tail to allow this. Often a doubly linked list is often used instead of this. The advantage of the linked list implementation is its ability to be resized and grown as much as necessary. The disadvantage of this is that the pointers involved in linked lists use more memory than a simple array.</li>\r\n                <li><b>Array Implementation:</b> An array is allocated with a certain capacity to represent the queue. The index of both ends of the queue are kept track of. When we remove or add an element, these indices are updated. The array is used in a circular fashion so that our queue maintains a constant maximum capacity. The advantages of this implementation are its simplicity and relatively low memory usage. The main disadvantage is that the size of the array cannot change so there is a limit to how much data can be stored. On the other hand, the space allocated may be way more than needed.</li>\r\n            </ul>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th></th><th>Array Implementation</th><th>Linked List Implementation</th></tr>\r\n                    <tr><th>Enqueue</th><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><th>Dequeue</th><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><th>Peek</th><td>O(1)</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default QueueInformation;","import React from 'react';\r\nimport './BinaryTreeDisplay.scss';\r\nimport Element from '../Element/Element';\r\n\r\n\r\n//react component for a single level in a binary tree\r\nconst BinaryTreeLevel = (props) => {\r\n    return props.list.map((node, index) => {\r\n        if (node === null)\r\n            return <Element key={index} value={\"\"} color={\"none\"} />;\r\n        else if (node === props.green)\r\n            return <Element key={index} value={node.value} color=\"green\" />;\r\n        else if (node === props.pink)\r\n            return <Element key={index} value={node.value} color=\"pink\" />;\r\n        else if (node === props.yellow)\r\n            return <Element key={index} value={node.value} color=\"yellow\" />;\r\n        else if (node === props.border)\r\n            return <Element key={index} value={node.value} border=\"bordered\" />;\r\n        else\r\n            return <Element key={index} value={node.value} />;\r\n    });\r\n}\r\n\r\n//react component for lines between binary tree nodes\r\nconst BinaryTreeLineLevel = (props) => {\r\n    var lines = [];\r\n    for (let i = 0; i < props.list.length; i++) {\r\n        if (props.list[i] === null)\r\n            lines.push(<div key={lines.length} className=\"binary-tree-line-none\"></div>);\r\n        else if (i % 2 === 0)\r\n            lines.push(<div key={lines.length} className=\"binary-tree-line-left\"></div>);\r\n        else\r\n            lines.push(<div key={lines.length} className=\"binary-tree-line-right\"></div>);\r\n        \r\n    }\r\n    return lines;\r\n}\r\n\r\n//react component to display the tree\r\nconst BinaryTreeDisplay = (props) => {\r\n    var levelComponents = [];\r\n    var nextQueue = [];\r\n    if (props.tree !== null)\r\n        nextQueue.push(props.tree.root);\r\n    var currQueue = [];\r\n    while (true) {\r\n        //continue breadth-first traversal creating BinaryTreeLevel component every iteration\r\n        currQueue = nextQueue;\r\n        nextQueue = [];\r\n        for (let i = 0; i < currQueue.length; i++) {\r\n            //use null as placeholder empty nodes in a level\r\n            if (currQueue[i] === null) {\r\n                nextQueue.push(null);\r\n                nextQueue.push(null);\r\n            } else {\r\n                nextQueue.push(currQueue[i].left);\r\n                nextQueue.push(currQueue[i].right);\r\n            }\r\n        }\r\n        //add a level of nodes\r\n        levelComponents.push(\r\n            <div key={levelComponents.length} className=\"binary-tree-level\">\r\n                <BinaryTreeLevel list={currQueue} border={props.border} green={props.green} pink={props.pink} yellow={props.yellow} />\r\n            </div>\r\n        );\r\n        //break loop if entire level is null\r\n        var allNull = true;\r\n        for (let i = 0; i < nextQueue.length; i++) {\r\n            if (nextQueue[i] !== null) {\r\n                allNull = false;\r\n            }\r\n        }\r\n        if (allNull) {\r\n            break;\r\n        }\r\n        //add a level of lines to the next level\r\n        levelComponents.push(\r\n            <div key={levelComponents.length} className=\"binary-tree-line-level\">\r\n                <BinaryTreeLineLevel list={nextQueue} />\r\n            </div>\r\n        );\r\n    }\r\n    return levelComponents;\r\n}\r\n\r\nexport default BinaryTreeDisplay;","import React, { useState, useEffect } from 'react';\r\nimport './BinaryTree.scss';\r\nimport BinaryTreeDisplay from './BinaryTreeDisplay.js';\r\n\r\n//class for node in binary tree\r\nexport class BinaryTreeNode {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\n\r\n//class for binary tree data structure\r\nexport class BinaryTreeClass {\r\n    constructor(root) {\r\n        this.root = root;\r\n    }\r\n}\r\n\r\n//main react component for binary tree\r\nconst BinaryTree = () => {\r\n\r\n    const [tree, setTree] = useState(null);\r\n    \r\n    //function to generate random tree\r\n    const randomTree = () => {\r\n        var newNodeChance = 0.9;\r\n        const levels = randInt(1,5);\r\n        var newTree = new BinaryTreeClass(new BinaryTreeNode(randInt(-999,1000)));\r\n        var nodes = [newTree.root];\r\n        var newNodes = [];\r\n        for (let level = 0; level < levels; level++) {\r\n            for (let i = 0; i < nodes.length; i++) {\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].left = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].left);\r\n                }\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].right = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].right);\r\n                }\r\n            }\r\n            nodes = newNodes;\r\n            newNodes = [];\r\n        }\r\n        setTree(newTree);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize tree to a random tree\r\n    useEffect(randomTree, []);\r\n\r\n    return (\r\n        <div className=\"binary-tree\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomTree}>Random</button>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <BinaryTreeDisplay tree={tree} />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default BinaryTree;","import React from 'react';\r\n\r\nconst BinaryTreeInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A Tree is a heirarchal data structure consisting of levels of nodes. Each node contains a value for that element in the tree, and some amount of pointers to children nodes. Since there can be any number of children nodes, a list is typically used to keep track of all of the children of a given node. The first node in the tree is known as the root, and is always kept track of as the start of the entire structure. The children of the root can be thought of as sub-trees, which are on there own also a data structure. Depending on how many children that a node has, the tree can be very different.</p>\r\n            <br />\r\n            <p>One specific type of Tree is a Binary Tree. A Binary Tree is a data structure in which each node in the tree contains at most two children nodes, a left and a right child. Each node contains the value of an element, a pointer to the left child node, and a pointer to the right child node. If a node does not have a left or right child it typically has a null pointer.</p>\r\n            <br />\r\n            <p><u>Binary Trees are used to implement several other data structures:</u></p>\r\n            <ul>\r\n                <li><b>Binary Search Tree:</b> elements are kept in an ordered pattern to allow for fast searching</li>\r\n                <li><b>AVL Tree:</b> after insertion or deletion the tree balances itself to keep a minimal height</li>\r\n                <li><b>Binary Heap:</b> elements are kept in an ordered pattern to keep extrema at the root</li>\r\n            </ul>\r\n            <br />\r\n            <p>When we consider trees, it is often useful to think about the height of the tree. This is because operations that require a single traversal down the tree will have a complexity equal to the height. Because of its heirarchical structure, a Binary Tree has an average-case height of O(log n) where n is the number of elements. In the worst-case where the tree is just a sequence of nodes with only right or left children, the height of the tree becomes O(n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Property</th><th>Worst-Case</th><th>Average-Case</th></tr>\r\n                    <tr><td>Height</td><td>O(n)</td><td>O(log n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinaryTreeInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './BinarySearchTree.scss';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay.js';\r\nimport Element from '../Element/Element.js';\r\n\r\n//class for node in binary tree\r\nclass BinaryTreeNode {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\n\r\n//class for binary search tree\r\nclass BinarySearchTreeClass {\r\n    constructor(){\r\n        this.root = null;\r\n        this.height = 0;\r\n    }\r\n\r\n    insert(value) {\r\n        var current = this.root;\r\n        var parent = null;\r\n        var height = 1;\r\n        while (current != null) {\r\n            if (value < current.value) {\r\n                parent = current;\r\n                current = current.left;\r\n                height++;\r\n            } else if (value > current.value) {\r\n                parent = current;\r\n                current = current.right;\r\n                height++;\r\n            } else\r\n                return;\r\n        }\r\n        if (parent === null)\r\n            this.root = new BinaryTreeNode(value);\r\n        else if (value < parent.value)\r\n            parent.left = new BinaryTreeNode(value);\r\n        else\r\n            parent.right = new BinaryTreeNode(value);\r\n        if (height > this.height)\r\n            this.height = height;\r\n    }\r\n\r\n    remove(value) {\r\n        var current = this.root;\r\n        var parent = null;\r\n        //find a node equal to value else exit function\r\n        while (true) {\r\n            if (current === null)\r\n                return;\r\n            if (value < current.value) {\r\n                parent = current;\r\n                current = current.left;\r\n            } else if (value > current.value) {\r\n                parent = current;\r\n                current = current.right;\r\n            } else\r\n                break;\r\n        }\r\n        //if node has no children set parent child to null\r\n        if (current.left === null && current.right === null) {\r\n            if (parent === null)\r\n                this.root = null;\r\n            else if (value < parent.value)\r\n                parent.left = null;\r\n            else\r\n                parent.right = null;\r\n        }\r\n        //if node has 1 child set parent child to current child\r\n        else if (current.right === null) {\r\n            if (parent === null)\r\n                this.root = current.left;\r\n            else if (value < parent.value)\r\n                parent.left = current.left;\r\n            else\r\n                parent.right = current.left;\r\n        }\r\n        else if (current.left === null) {\r\n            if (parent === null)\r\n                this.root = current.right;\r\n            else if (value < parent.value)\r\n                parent.left = current.right;\r\n            else\r\n                parent.right = current.right;\r\n        }\r\n        //if node has 2 children set parent child to leftmost node of right subtree of current, and delete that\r\n        else {\r\n            //find the leftmost child of right subtree of current, set current to that value\r\n            var leftmostChild = current.right;\r\n            parent = current;\r\n            while (leftmostChild.left !== null) {\r\n                parent = leftmostChild;\r\n                leftmostChild = leftmostChild.left;\r\n            }\r\n            current.value = leftmostChild.value;\r\n            //delete the leftmost child of right subtree\r\n            current = leftmostChild;\r\n            if (current.left === null && current.right === null) {\r\n                if (current.value < parent.value)\r\n                    parent.left = null;\r\n                else\r\n                    parent.right = null;\r\n            }\r\n            else if (current.right === null) {\r\n                if (current.value < parent.value)\r\n                    parent.left = current.left;\r\n                else\r\n                    parent.right = current.left;\r\n            }\r\n            else {\r\n                if (current.value < parent.value)\r\n                    parent.left = current.right;\r\n                else\r\n                    parent.right = current.right;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//react component for binary search tree\r\nconst BinarySearchTree = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [tree, setTree] = useState(new BinarySearchTreeClass());\r\n    const insertInput = useRef();\r\n    const removeInput = useRef();\r\n    const findInput = useRef();\r\n    const speedSlider = useRef();\r\n    const focus = useRef();\r\n    const green = useRef();\r\n    const pink = useRef();\r\n    const yellow = useRef();\r\n    const interval = useRef();\r\n    const animating = useRef();\r\n    const animationFunction = useRef();\r\n    const animationValue = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to generate a random BST\r\n    const randomTree = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        const height = randInt(2,6);\r\n        var newTree = new BinarySearchTreeClass();\r\n        var insertValue = null;\r\n        while(newTree.height <= height) {\r\n            insertValue = randInt(-999,1000);\r\n            newTree.insert(insertValue);\r\n        }\r\n        newTree.remove(insertValue);\r\n        setTree(newTree);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //function to pause or continue animation\r\n    const toggleAnimation = useCallback(() => {\r\n        if (animating.current) {\r\n            clearInterval(interval.current);\r\n            animating.current = false;\r\n            focus.current = null;\r\n            animationFunction.current = null;\r\n            animationValue.current = null;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            green.current = null;\r\n            yellow.current = null;\r\n            animating.current = true;\r\n        }\r\n    }, []);\r\n    \r\n    //initialize the tree to a random BST\r\n    useEffect(randomTree, [toggleAnimation]);\r\n\r\n    //function to insert into the binary search tree on button click\r\n    const insert = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var data = parseInt(insertInput.current.value);\r\n        if (isNaN(data))\r\n            data = randInt(-999, 1000);\r\n        insertInput.current.value = null;\r\n        if (tree.root === null) {\r\n            tree.insert(data);\r\n            green.current = tree.root;\r\n            forceUpdate();\r\n        } else {\r\n            focus.current = tree.root;\r\n            forceUpdate();\r\n            animationFunction.current = insertStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to do a single step of insertion animation\r\n    const insertStep = () => {\r\n        if (animationValue.current < focus.current.value) {\r\n            if (focus.current.left === null) {\r\n                tree.insert(animationValue.current);\r\n                green.current = focus.current.left;\r\n                toggleAnimation();\r\n            } else\r\n                focus.current = focus.current.left;\r\n        } else if (animationValue.current > focus.current.value) {\r\n            if (focus.current.right === null) {\r\n                tree.insert(animationValue.current);\r\n                green.current = focus.current.right;\r\n                toggleAnimation();\r\n            } else\r\n                focus.current = focus.current.right;\r\n        } else {\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to remove from binary search tree on button click\r\n    const remove = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        if(tree.root !== null) {\r\n            var data = parseInt(removeInput.current.value);\r\n            if (isNaN(data))\r\n                data = tree.root.value;\r\n            focus.current = tree.root;\r\n            if (focus.current.value === data)\r\n                pink.current = focus.current;\r\n            forceUpdate();\r\n            animationFunction.current = removeStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n        }\r\n        removeInput.current.value = null;\r\n    }\r\n\r\n    //function to do a single step of remove animation\r\n    const removeStep = () => {\r\n        if (animationValue.current < focus.current.value) {\r\n            if (focus.current.left === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.left;\r\n                if (focus.current.value === animationValue.current)\r\n                    pink.current = focus.current;\r\n            }\r\n        } else if (animationValue.current > focus.current.value) {\r\n            if (focus.current.right === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.right;\r\n                if (focus.current.value === animationValue.current)\r\n                    pink.current = focus.current;\r\n            }\r\n        } else {\r\n            tree.remove(animationValue.current);\r\n            pink.current = null;\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to start find animation\r\n    const find = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        if(tree.root !== null) {\r\n            var data = parseInt(findInput.current.value);\r\n            if (isNaN(data))\r\n                data = tree.root.value;\r\n            focus.current = tree.root;\r\n            animationFunction.current = findStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n            if (focus.current.value === data)\r\n                yellow.current = focus.current;\r\n            forceUpdate();\r\n        }\r\n        findInput.current.value = null;\r\n    }\r\n\r\n    //function to to a single step of find animation\r\n    const findStep = () => {\r\n        if (animationValue.current < focus.current.value) {\r\n            if (focus.current.left === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.left;\r\n                if (focus.current.value === animationValue.current)\r\n                    yellow.current = focus.current;\r\n            }\r\n        } else if (animationValue.current > focus.current.value) {\r\n            if (focus.current.right === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.right;\r\n                if (focus.current.value === animationValue.current)\r\n                    yellow.current = focus.current;\r\n            }\r\n        } else {\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //changes the animation speed when the slider changes\r\n    const updateSpeed = () => {\r\n        if (animationFunction.current != null) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"binary-search-tree\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={randomTree}>Random</button>\r\n                    <br />\r\n                    <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                    <input ref={insertInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                    <input ref={removeInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"findButton\" onClick={find}>Find</button>\r\n                    <input ref={findInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <BinaryTreeDisplay tree={tree} border={focus.current} green={green.current} pink={pink.current} yellow={yellow.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n                <br />\r\n                <Element color=\"green\"></Element>\r\n                <p>= Last Inserted Element</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Element to Delete</p>\r\n                <br />\r\n                <Element color=\"yellow\"></Element>\r\n                <p>= Last Found Element</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default BinarySearchTree;","import React from 'react';\r\n\r\nconst BinarySearchTreeInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A Binary Search Tree is a tree data structure where elements are kept in an ordered pattern. For any given node, all of the elements in the left sub-tree are less than or equal to the given node, and all of the elements in the right sub-tree are greater than or equal to the given node.</p>\r\n            <br />\r\n            <p><u>A Binary Search Tree has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into tree</li>\r\n                <li><b>Remove:</b> removes an element from the tree</li>\r\n                <li><b>Find:</b> searches for an element in the tree</li>\r\n            </ul>\r\n            <br />\r\n            <p>In order to maintain the ordered property of the tree, insertion and removal of elements must be done in a careful manner. For insertion the tree is traversed going left if the new value is less than the current node and going right if the new value is greater than the current node. Once we reach an empty spot, a new node is created there with the new value.</p>\r\n            <br />\r\n            <p>To remove a value from the tree, it becomes more complex. First we traverse the tree to find the node of the value we want to remove. If it has no children, we simply set its parent's child to null. If it has 1 child, we set its parent's child to its child. If it has 2 children, we find the leftmost child of the right sub-tree of the current node, set the current node to that value, and then delete the leftmost child of the right sub-tree. This can also be done with the rightmost child of the left sub-tree.</p>\r\n            <br />\r\n            <p>To understand the complexity of the operations in a Binary Search Tree we must consider the height of the tree. In the worst-case, the tree will be a straight line, and the height will be equal to the number of elements, O(n). In the average-case and best-case, the height of the tree will be O(log n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Worst-Case</th><th>Average-Case</th></tr>\r\n                    <tr><td>Insert</td><td>O(n)</td><td>O(log n)</td></tr>\r\n                    <tr><td>Remove</td><td>O(n)</td><td>O(log n)</td></tr>\r\n                    <tr><td>Find</td><td>O(n)</td><td>O(log n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinarySearchTreeInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './AvlTree.scss';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay.js';\r\nimport Element from '../Element/Element.js';\r\n\r\n//class for node in binary tree\r\nclass BinaryTreeNode {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n\r\n}\r\n\r\nfunction getParent(node, tree) {\r\n    var parent = null;\r\n    var cur = tree.root;\r\n    if (node != null) {\r\n\r\n        while (cur !== node) {\r\n            if (node.value > cur.value) {\r\n                parent = cur;\r\n                cur = parent.right;\r\n            }\r\n            else {\r\n                parent = cur;\r\n                cur = parent.left;\r\n            }\r\n        }\r\n        return parent;\r\n    }\r\n    else console.log(\"node is null, no parent\")\r\n}\r\n\r\nfunction getHeight(node) {\r\n\r\n    if (typeof node === \"object\" && node != null) {\r\n\r\n        if (getHeight(node.left) > getHeight(node.right)) {\r\n            return 1 + getHeight(node.left);\r\n        }\r\n        else return 1 + getHeight(node.right);\r\n    }\r\n    else return 0;\r\n}\r\n\r\n\r\nfunction getBalance(node) {\r\n    if (node !== null && typeof node != \"undefined\") {\r\n        return getHeight(node.right) - getHeight(node.left);\r\n    }\r\n}\r\n\r\nfunction rotateRight(node, tree) {\r\n    var newRoot = node.left;\r\n    if (node === tree.root) tree.root = newRoot;\r\n    var T2 = newRoot.right;\r\n\r\n    newRoot.right = node;\r\n    node.left = T2;\r\n\r\n}\r\n\r\nfunction rotateLeft(node, tree) {\r\n    var newRoot = node.right;\r\n    if (node === tree.root) tree.root = newRoot;\r\n    var T2 = newRoot.left;\r\n    newRoot.left = node;\r\n    node.right = T2;\r\n}\r\n\r\nfunction getLeftmost(node) {\r\n    var leftmost = node;\r\n    if (leftmost != null) {\r\n        while (leftmost.left != null) {\r\n            leftmost = leftmost.left;\r\n        }\r\n    }\r\n    return leftmost;\r\n}\r\n\r\nfunction getRightMost(node) {\r\n    var rightmost = node;\r\n    if (rightmost != null) {\r\n        while (rightmost.right != null) {\r\n            rightmost = rightmost.right;\r\n        }\r\n    }\r\n    return rightmost;\r\n}\r\n\r\n//class for binary search tree\r\nclass AvlTreeClass {\r\n    constructor() {\r\n        this.root = null;\r\n        this.height = 0;\r\n        this.list = [];\r\n    }\r\n\r\n\r\n\r\n\r\n    inOrder(node) {\r\n        if (node == null) {\r\n            return\r\n        }\r\n        this.inOrder(node.left);\r\n        this.list.push(node.value);\r\n        this.inOrder(node.right);\r\n    }\r\n\r\n    insertWithRot(value) {\r\n        var current = this.root;\r\n        var parent = null;\r\n        var height = 1;\r\n        while (current != null) {\r\n            if (value < current.value) {\r\n                parent = current;\r\n                current = current.left;\r\n                height++;\r\n            } else if (value > current.value) {\r\n                parent = current;\r\n                current = current.right;\r\n                height++;\r\n            } else\r\n                return;\r\n        }\r\n        if (parent === null)\r\n            this.root = new BinaryTreeNode(value);\r\n        else if (value < parent.value)\r\n            parent.left = new BinaryTreeNode(value);\r\n        else\r\n            parent.right = new BinaryTreeNode(value);\r\n        if (height > this.height)\r\n            this.height = height;\r\n\r\n        //do rotations\r\n    }\r\n\r\n    insert(value) {\r\n        var current = this.root;\r\n        var parent = null;\r\n        var height = 1;\r\n        while (current != null) {\r\n            if (value < current.value) {\r\n                parent = current;\r\n                current = current.left;\r\n                height++;\r\n            } else if (value > current.value) {\r\n                parent = current;\r\n                current = current.right;\r\n                height++;\r\n            } else\r\n                return;\r\n        }\r\n        if (parent === null)\r\n            this.root = new BinaryTreeNode(value);\r\n        else if (value < parent.value)\r\n            parent.left = new BinaryTreeNode(value);\r\n        else\r\n            parent.right = new BinaryTreeNode(value);\r\n        if (height > this.height)\r\n            this.height = height;\r\n    }\r\n\r\n    remove(value) {\r\n        var current = this.root;\r\n        var parent = null;\r\n        //find a node equal to value else exit function\r\n        while (true) {\r\n            if (current === null)\r\n                return;\r\n            if (value < current.value) {\r\n                parent = current;\r\n                current = current.left;\r\n            } else if (value > current.value) {\r\n                parent = current;\r\n                current = current.right;\r\n            } else\r\n                break;\r\n        }\r\n        //if node has no children set parent child to null\r\n        if (current.left === null && current.right === null) {\r\n            if (parent === null)\r\n                this.root = null;\r\n            else if (value < parent.value)\r\n                parent.left = null;\r\n            else\r\n                parent.right = null;\r\n        }\r\n        //if node has 1 child set parent child to current child\r\n        else if (current.right === null) {\r\n            if (parent === null)\r\n                this.root = current.left;\r\n            else if (value < parent.value)\r\n                parent.left = current.left;\r\n            else\r\n                parent.right = current.left;\r\n        }\r\n        else if (current.left === null) {\r\n            if (parent === null)\r\n                this.root = current.right;\r\n            else if (value < parent.value)\r\n                parent.left = current.right;\r\n            else\r\n                parent.right = current.right;\r\n        }\r\n        //if node has 2 children set parent child to leftmost node of right subtree of current, and delete that\r\n        else {\r\n            //find the leftmost child of right subtree of current, set current to that value\r\n            var leftmostChild = current.right;\r\n            parent = current;\r\n            while (leftmostChild.left !== null) {\r\n                parent = leftmostChild;\r\n                leftmostChild = leftmostChild.left;\r\n            }\r\n            current.value = leftmostChild.value;\r\n            //delete the leftmost child of right subtree\r\n            current = leftmostChild;\r\n            if (current.left === null && current.right === null) {\r\n                if (current.value < parent.value)\r\n                    parent.left = null;\r\n                else\r\n                    parent.right = null;\r\n            }\r\n            else if (current.right === null) {\r\n                if (current.value < parent.value)\r\n                    parent.left = current.left;\r\n                else\r\n                    parent.right = current.left;\r\n            }\r\n            else {\r\n                if (current.value < parent.value)\r\n                    parent.left = current.right;\r\n                else\r\n                    parent.right = current.right;\r\n            }\r\n        }\r\n    }\r\n\r\n    treeHeight() {\r\n        return getHeight(this.root);\r\n    }\r\n\r\n}\r\n\r\n//converts sorted array to AVL Tree\r\nfunction sortedArrayToAVL(arr, start, end) {\r\n    if (start > end) {\r\n        return null;\r\n    }\r\n\r\n    var mid = parseInt((start + end) / 2);\r\n    var node = new BinaryTreeNode(arr[mid]);\r\n\r\n    node.left = sortedArrayToAVL(arr, start, mid - 1);\r\n\r\n    node.right = sortedArrayToAVL(arr, mid + 1, end);\r\n    return node;\r\n}\r\n\r\n//react component for binary search tree\r\nconst AvlTree = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [tree, setTree] = useState(new AvlTreeClass());\r\n    const secondRot = useRef(false);\r\n    const familyLine = useRef([]);\r\n    const insertInput = useRef();\r\n    const removeInput = useRef();\r\n    const findInput = useRef();\r\n    const speedSlider = useRef();\r\n    const focus = useRef();\r\n    const green = useRef();\r\n    const pink = useRef();\r\n    const yellow = useRef();\r\n    const interval = useRef();\r\n    const animating = useRef();\r\n    const animationFunction = useRef();\r\n    const animationValue = useRef();\r\n    const status = useRef(\"Tree is balanced\");\r\n\r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //function to generate a random BST\r\n    const randomTree = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        const height = randInt(2, 6);\r\n        var newTree = new AvlTreeClass();\r\n        var insertValue = null;\r\n        while (newTree.height <= height) {\r\n            insertValue = randInt(-999, 1000);\r\n            newTree.insert(insertValue);\r\n        }\r\n\r\n        newTree.remove(insertValue);\r\n        newTree.inOrder(newTree.root)\r\n\r\n\r\n        var treeList = newTree.list;\r\n        var n = newTree.list.length;\r\n        newTree.root = sortedArrayToAVL(treeList, 0, n - 1);\r\n\r\n        setTree(newTree);\r\n    }\r\n\r\n\r\n\r\n\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max - min) + min);\r\n    }\r\n\r\n    //function to pause or continue animation\r\n    const toggleAnimation = useCallback(() => {\r\n\r\n        if (animating.current) {\r\n            clearInterval(interval.current);\r\n            animating.current = false;\r\n            focus.current = null;\r\n            animationFunction.current = null;\r\n            animationValue.current = null;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n            green.current = null;\r\n            yellow.current = null;\r\n            animating.current = true;\r\n        }\r\n    }, []);\r\n\r\n    //initialize the tree to a random BST\r\n    useEffect(randomTree, [toggleAnimation]);\r\n\r\n    //function to insert into the binary search tree on button click\r\n    const insert = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        var data = parseInt(insertInput.current.value);\r\n        if (isNaN(data))\r\n            data = randInt(-999, 1000);\r\n        insertInput.current.value = null;\r\n        if (tree.root === null) {\r\n            tree.insert(data);\r\n            green.current = tree.root;\r\n            forceUpdate();\r\n        } else {\r\n            focus.current = tree.root;\r\n            forceUpdate();\r\n            animationFunction.current = insertStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n        }\r\n        familyLine.current = [];\r\n    }\r\n\r\n    //function to do a single step of insertion animation\r\n    const insertStep = () => {\r\n        status.current = \"Inserting node\";\r\n        forceUpdate();\r\n        if (animationValue.current < focus.current.value) {\r\n            familyLine.current.push(focus.current);\r\n            if (focus.current.left === null) {\r\n                tree.insert(animationValue.current);\r\n                //familyLine.current.push(focus.current);\r\n                green.current = focus.current.left;\r\n                //toggleAnimation();\r\n                //animationFunction.current = rotateStep();\r\n                focus.current = focus.current.left;\r\n            } else\r\n                focus.current = focus.current.left;\r\n\r\n        } else if (animationValue.current > focus.current.value) {\r\n            familyLine.current.push(focus.current);\r\n            if (focus.current.right === null) {\r\n                tree.insert(animationValue.current);\r\n                //familyLine.current.push(focus.current);\r\n                green.current = focus.current.right;\r\n                focus.current = focus.current.right;\r\n                //toggleAnimation();\r\n                //animationFunction.current = rotateStep();\r\n            } else\r\n                focus.current = focus.current.right;\r\n\r\n        } else {\r\n            animationFunction.current = rotateStep;\r\n        }\r\n\r\n    }\r\n\r\n    //function to remove from binary search tree on button click\r\n    const remove = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        if (tree.root !== null) {\r\n            var data = parseInt(removeInput.current.value);\r\n            if (isNaN(data))\r\n                data = tree.root.value;\r\n            focus.current = tree.root;\r\n            if (focus.current.value === data)\r\n                pink.current = focus.current;\r\n            forceUpdate();\r\n            animationFunction.current = removeStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n        }\r\n        removeInput.current.value = null;\r\n        familyLine.current = [];\r\n    }\r\n\r\n    //function to do a single step of remove animation\r\n    const removeStep = () => {\r\n        status.current = \"Removing node\";\r\n        if (animationValue.current < focus.current.value) {\r\n            familyLine.current.push(focus.current);\r\n            if (focus.current.left === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.left;\r\n                if (focus.current.value === animationValue.current)\r\n                    pink.current = focus.current;\r\n            }\r\n        } else if (animationValue.current > focus.current.value) {\r\n            familyLine.current.push(focus.current);\r\n            if (focus.current.right === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.right;\r\n                if (focus.current.value === animationValue.current)\r\n                    pink.current = focus.current;\r\n            }\r\n        } else {\r\n            if (familyLine.current.length === 0) {\r\n                var rightTree = tree.root.right;\r\n                if (rightTree != null) {\r\n                    if (getParent(getLeftmost(rightTree), tree) === tree.root) {\r\n                        tree.remove(animationValue.current);\r\n                        familyLine.current.push(tree.root);\r\n                        pink.current = null;\r\n                        animationFunction.current = rotateStepDelete;\r\n                        return;\r\n                    }\r\n                    else familyLine.current.push(getParent(getLeftmost(rightTree), tree));\r\n\r\n                }\r\n                else {\r\n\r\n                    if (getParent(getRightMost(tree.root.left), tree) === tree.root) {\r\n                        tree.remove(animationValue.current);\r\n                        familyLine.current.push(tree.root);\r\n                        pink.current = null;\r\n                        animationFunction.current = rotateStepDelete;\r\n                        return;\r\n                    }\r\n                    else familyLine.current.push(getParent(getRightMost(tree.root.left), tree));\r\n\r\n                }\r\n            }\r\n            tree.remove(animationValue.current);\r\n\r\n            pink.current = null;\r\n            animationFunction.current = rotateStepDelete;\r\n        }\r\n    }\r\n\r\n\r\n    //function to start find animation\r\n    const find = () => {\r\n        if (animating.current) {\r\n            familyLine.current = [];\r\n            toggleAnimation();\r\n        }\r\n        if (tree.root !== null) {\r\n            var data = parseInt(findInput.current.value);\r\n            if (isNaN(data))\r\n                data = tree.root.value;\r\n            focus.current = tree.root;\r\n            animationFunction.current = findStep;\r\n            animationValue.current = data;\r\n            toggleAnimation();\r\n            if (focus.current.value === data)\r\n                yellow.current = focus.current;\r\n            forceUpdate();\r\n        }\r\n        findInput.current.value = null;\r\n    }\r\n\r\n    //function to to a single step of find animation\r\n    const findStep = () => {\r\n        if (animationValue.current < focus.current.value) {\r\n            if (focus.current.left === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.left;\r\n                if (focus.current.value === animationValue.current)\r\n                    yellow.current = focus.current;\r\n            }\r\n        } else if (animationValue.current > focus.current.value) {\r\n            if (focus.current.right === null)\r\n                toggleAnimation();\r\n            else {\r\n                focus.current = focus.current.right;\r\n                if (focus.current.value === animationValue.current)\r\n                    yellow.current = focus.current;\r\n            }\r\n        } else {\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    const rotateStepDelete = () => {\r\n\r\n        var family = [];\r\n        for (var i = 0; i < familyLine.current.length; i++) {\r\n            family.push(familyLine.current[i]);\r\n        }\r\n\r\n        if (family.length === 0) toggleAnimation();\r\n        else {\r\n\r\n            //z is first unbalanced node\r\n\r\n            var z = family.pop();\r\n\r\n\r\n\r\n            while (family.length > 0 && Math.abs(getBalance(z)) < 2) {\r\n                z = family.pop();\r\n\r\n            }\r\n            if (Math.abs(getBalance(z)) < 2) {\r\n                status.current = \"Tree is balanced\";\r\n\r\n                toggleAnimation();\r\n            }\r\n\r\n            familyLine.current = [];\r\n            familyLine.current.push(z);\r\n            //determine largest height child\r\n\r\n            if (z == null || typeof z == \"undefined\") {\r\n                status.current = \"Tree is empty\"\r\n                toggleAnimation();\r\n            }\r\n            else if (z.left != null || z.right != null) {\r\n                var y = null; //largest height child\r\n                if (getHeight(z.left) >= getHeight(z.right)) {\r\n                    y = z.left\r\n\r\n                }\r\n                else y = z.right;\r\n                var x = null;\r\n                if (y != null) {\r\n                    if (y.value < z.value) {\r\n                        if (getHeight(y.left) >= getHeight(y.right)) x = y.left;\r\n                        else x = y.right;\r\n                    }\r\n                    else {\r\n                        if (getHeight(y.left) > getHeight(y.right)) x = y.left;\r\n                        else x = y.right;\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n            ////left left\r\n            if (getBalance(z) < -1 && x.value < y.value) {\r\n                rotateRight(z, tree);\r\n                status.current = \"Rotating Node: \" + z.value + \" right\"\r\n                let parent = getParent(y, tree);\r\n                if (parent != null) {\r\n                    if (parent.value < z.value) {\r\n                        parent.right = y;\r\n                    }\r\n                    else parent.left = y;\r\n                }\r\n                //familyLine.current.shift();\r\n            }\r\n\r\n            ////left right\r\n            if (getBalance(z) < -1 && x.value > y.value) {\r\n\r\n                rotateLeft(y, tree);\r\n                status.current = \"Rotating Node: \" + y.value + \" left\"\r\n                z.left = x;\r\n\r\n\r\n            }\r\n\r\n            ////right left\r\n            if (getBalance(z) > 1 && x.value < y.value) {\r\n\r\n                rotateRight(y, tree);\r\n                status.current = \"Rotating Node: \" + y.value + \" right\"\r\n                z.right = x;\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n            //right right\r\n            if (getBalance(z) > 1 && x.value > y.value) {\r\n                let parent = getParent(z, tree);\r\n                rotateLeft(z, tree);\r\n                status.current = \"Rotating Node: \" + z.value + \" left\"\r\n\r\n                if (parent != null) {\r\n                    if (parent.value < z.value) {\r\n                        parent.right = y;\r\n                    }\r\n                    else parent.left = y;\r\n                }\r\n                else tree.root = y;\r\n\r\n            }\r\n\r\n            forceUpdate();\r\n\r\n\r\n        }\r\n    }\r\n\r\n    const rotateStep = () => {\r\n\r\n        //create new array copy of family line\r\n        var family = [];\r\n        for (var i = 0; i < familyLine.current.length; i++) {\r\n            family.push(familyLine.current[i]);\r\n        }\r\n\r\n\r\n        //var inserted = green.current;\r\n\r\n        if (family.length === 0) toggleAnimation();\r\n        else {\r\n            var firstUnbalanced = family.pop();\r\n\r\n            //var child;\r\n\r\n            while (Math.abs(getBalance(firstUnbalanced)) < 2 && family.length > 0) {\r\n                firstUnbalanced = family.pop();\r\n\r\n            }\r\n\r\n\r\n            if (Math.abs(getBalance(firstUnbalanced)) < 2) {\r\n                //tree is balanced \r\n                status.current = \"Tree is balanced\"\r\n                toggleAnimation();\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            //Left Left case\r\n            if (getBalance(firstUnbalanced) === -2 && getBalance(firstUnbalanced.left) === -1) {\r\n\r\n\r\n                let l = firstUnbalanced.left;\r\n                rotateRight(firstUnbalanced, tree);\r\n                status.current = \"Rotating Node: \" + firstUnbalanced.value + \" right\"\r\n\r\n                //insert on correct side\r\n                let grandP = family.pop();\r\n                if (grandP) {\r\n                    if (grandP.value < firstUnbalanced.value) {\r\n                        grandP.right = l;\r\n                    }\r\n                    else grandP.left = l;\r\n                } else tree.root = l;\r\n                secondRot.current = true;\r\n                familyLine.current.splice(familyLine.current.indexOf(l.right), 1);\r\n\r\n\r\n            }\r\n\r\n\r\n            //Left Right case\r\n            if (getBalance(firstUnbalanced) === -2 && getBalance(firstUnbalanced.left) === 1) {\r\n                let r = firstUnbalanced.left.right;\r\n                rotateLeft(firstUnbalanced.left, tree);\r\n                status.current = \"Rotating Node: \" + firstUnbalanced.left.value + \" left\";\r\n\r\n                firstUnbalanced.left = r;\r\n            }\r\n\r\n            //Right Right case\r\n            if (getBalance(firstUnbalanced) === 2 && getBalance(firstUnbalanced.right) === 1) {\r\n                let r = firstUnbalanced.right;\r\n                rotateLeft(firstUnbalanced, tree);\r\n                status.current = \"Rotating Node: \" + firstUnbalanced.value + \" left\";\r\n                //insert on correct side\r\n                let grandP = family.pop();\r\n                if (grandP) {\r\n                    if (grandP.value < firstUnbalanced.value) {\r\n                        grandP.right = r;\r\n                    }\r\n                    else grandP.left = r;\r\n                } else tree.root = r;\r\n                familyLine.current.splice(familyLine.current.indexOf(firstUnbalanced), 1);\r\n\r\n            }\r\n\r\n            //Right Left Case\r\n            if (getBalance(firstUnbalanced) === 2 && getBalance(firstUnbalanced.right) === -1) {\r\n                let l = firstUnbalanced.right.left;\r\n                rotateRight(firstUnbalanced.right, tree);\r\n                status.current = \"Rotating Node: \" + firstUnbalanced.right + \" right\";\r\n                familyLine.current.pop();\r\n                firstUnbalanced.right = l;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n        }\r\n        forceUpdate();\r\n\r\n    }\r\n\r\n    //changes the animation speed when the slider changes\r\n    const updateSpeed = () => {\r\n        if (animationFunction.current != null) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"binary-search-tree\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={randomTree}>Random</button>\r\n                    <br />\r\n                    <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                    <input ref={insertInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                    <input ref={removeInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"findButton\" onClick={find}>Find</button>\r\n                    <input ref={findInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <BinaryTreeDisplay tree={tree} border={focus.current} green={green.current} pink={pink.current} yellow={yellow.current} />\r\n\r\n                    <p>{status.current}</p>\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n                <br />\r\n                <Element color=\"green\"></Element>\r\n                <p>= Last Inserted Element</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Element to Delete</p>\r\n                <br />\r\n                <Element color=\"yellow\"></Element>\r\n                <p>= Last Found Element</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default AvlTree;","import React from 'react';\r\n\r\nconst AvlTreeInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>An AVL Tree is a self-balancing binary search tree. Thus, it inherits the properties of order as well as the restriction that each node has either zero, one, or two children. The additional restriction placed on AVL Trees is that the height of two sibling subtrees differ by at most one. It maintains this condition by performing a series of rotational operations on nodes following insertion and deletion.</p>\r\n            \r\n            <br />\r\n            <p><u>An AVL Tree has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into tree</li>\r\n                <li><b>Remove:</b> removes an element from the tree</li>\r\n                <li><b>Find:</b> searches for an element in the tree</li>\r\n            </ul>\r\n            <br />\r\n            <p>At insertion, a regular BST insertion is performed. Next, if there is an unbalanced node found on the path up from the newly inserted node to the root, then a rotation will occur. The exact rotation operation depends on the relative postions of the first unbalanced node and its two immediate adjacent ancestors on the path back to the newly inserted node.</p>\r\n            <br />\r\n            <p>Likewise, at deletion, a regular BST deletion is performed and a rotation may also occur. However, whether or not the rotation occurs and the exact rotation operation depends instead on the relative positions of the first unbalanced node on the path up the tree as well as its two immediate ancestors that are each the largest height child of their parent node.</p>\r\n            <br />\r\n            <p>Because of the fact that AVL Trees maintain a balanced state, they have advantages over a traditional Binary Search Tree. The height of the tree will always be O(log n), where as a regular BST may have a height of O(n). The worst-case time complexities for each basic operation are O(log n) in an AVL Tree rather than O(n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Worst-Case</th><th>Average-Case</th><th>BST Worst-Case</th></tr>\r\n                    <tr><td>Insert</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>\r\n                    <tr><td>Remove</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>\r\n                    <tr><td>Find</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AvlTreeInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './BinaryHeap.scss';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay.js';\r\nimport { BinaryTreeNode, BinaryTreeClass } from '../BinaryTree/BinaryTree.js';\r\n\r\n//class for binary heap data structure\r\nexport class BinaryHeapClass {\r\n    constructor() {\r\n        this.heap = [];\r\n        this.focus = null;\r\n        this.focusNode = null;\r\n        this.green = null;\r\n        this.greenNode = null;\r\n        this.pink = null;\r\n        this.pinkNode = null;\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        var current = this.heap.length-1;\r\n        var parent = Math.floor((current-1)/2);\r\n        while(parent >= 0) {\r\n            if (this.heap[current] < this.heap[parent]) {\r\n                let temp = this.heap[parent];\r\n                this.heap[parent] = this.heap[current];\r\n                this.heap[current] = temp;\r\n                current = parent;\r\n                parent = Math.floor((current-1)/2);\r\n            } else\r\n                break;\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        if (this.heap.length !== 0) {\r\n            var returnValue = this.heap[0];\r\n            if (this.heap.length === 1)\r\n                this.heap = [];\r\n            else {\r\n                this.heap[0] = this.heap.pop();\r\n                var current = 0;\r\n                while (current < this.heap.length) {\r\n                    if (2 * current + 2 < this.heap.length) {\r\n                        if (this.heap[current] <= this.heap[2 * current + 1] && this.heap[current] <= this.heap[2 * current + 2]) {\r\n                            break;\r\n                        } else if (this.heap[2 * current + 1] < this.heap[2 * current + 2]) {\r\n                            let temp = this.heap[current];\r\n                            this.heap[current] = this.heap[2 * current + 1];\r\n                            this.heap[2 * current + 1] = temp;\r\n                            current = 2 * current + 1;\r\n                        } else {\r\n                            let temp = this.heap[current];\r\n                            this.heap[current] = this.heap[2 * current + 2];\r\n                            this.heap[2 * current + 2] = temp;\r\n                            current = 2 * current + 2;\r\n                        }\r\n                    } else if (2 * current + 1 < this.heap.length) {\r\n                        if (this.heap[current] > this.heap[2 * current + 1]) {\r\n                            let temp = this.heap[current];\r\n                            this.heap[current] = this.heap[2 * current + 1];\r\n                            this.heap[2 * current + 1] = temp;\r\n                            current = 2 * current + 1;\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return returnValue;\r\n        }\r\n    }\r\n\r\n    getTree() {\r\n        var tree = new BinaryTreeClass(null);\r\n        this.focusNode = null;\r\n        this.greenNode = null;\r\n        this.pinkNode = null;\r\n        if (this.heap.length !== 0) {\r\n            tree.root = new BinaryTreeNode(this.heap[0]);\r\n            if (this.focus === 0)\r\n                this.focusNode = tree.root;\r\n            if (this.green === 0)\r\n                this.greenNode = tree.root;\r\n            if (this.pink === 0)\r\n                this.pinkNode = tree.root;\r\n            var nodes = [tree.root];\r\n            var newNodes = [];\r\n            var indices = [0];\r\n            var newIndices = [];\r\n            while (nodes.length !== 0) {\r\n                for (let i = 0; i < nodes.length; i++) {\r\n                    if (2*indices[i]+1 < this.heap.length) {\r\n                        nodes[i].left = new BinaryTreeNode(this.heap[2*indices[i]+1]);\r\n                        if (2*indices[i]+1 === this.focus)\r\n                            this.focusNode = nodes[i].left;\r\n                        if (2*indices[i]+1 === this.green)\r\n                            this.greenNode = nodes[i].left;\r\n                        if (2*indices[i]+1 === this.pink)\r\n                            this.pinkNode = nodes[i].left;\r\n                        newNodes.push(nodes[i].left);\r\n                        newIndices.push(2*indices[i]+1);\r\n                    }\r\n                    if (2*indices[i]+2 < this.heap.length) {\r\n                        nodes[i].right = new BinaryTreeNode(this.heap[2*indices[i]+2]);\r\n                        if (2*indices[i]+2 === this.focus)\r\n                            this.focusNode = nodes[i].right;\r\n                        if (2*indices[i]+2 === this.green)\r\n                            this.greenNode = nodes[i].right;\r\n                        if (2*indices[i]+2 === this.pink)\r\n                            this.pinkNode = nodes[i].right;\r\n                        newNodes.push(nodes[i].right);\r\n                        newIndices.push(2*indices[i]+2);\r\n                    }\r\n                }\r\n                nodes = newNodes;\r\n                newNodes = [];\r\n                indices = newIndices;\r\n                newIndices = [];\r\n            }\r\n        }\r\n        return tree;\r\n    }\r\n}\r\n\r\n//main react component for binary heap visualization\r\nconst BinaryHeap = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [heap, setHeap] = useState(new BinaryHeapClass());\r\n    const insertInput = useRef();\r\n    const speedSlider = useRef();\r\n    const interval = useRef();\r\n    const animating = useRef();\r\n    const animationFunction = useRef();\r\n    const animationCurrent = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to create a random heap\r\n    const randomHeap = () => {\r\n        if (animating.current)\r\n            toggleAnimation();\r\n        const elements = randInt(2,32);\r\n        var newHeap = new BinaryHeapClass();\r\n        for (let i = 0; i < elements; i++)\r\n            newHeap.insert(randInt(-999,1000));\r\n        setHeap(newHeap);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //function to pause or continue animation\r\n    const toggleAnimation = useCallback(() => {\r\n        if (animating.current) {\r\n            clearInterval(interval.current);\r\n            animating.current = false;\r\n            animationFunction.current = null;\r\n            animationCurrent.current = null;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            animating.current = true;\r\n        }\r\n    }, []);\r\n\r\n    //initialize the tree to a random binary heap\r\n    useEffect(randomHeap, [toggleAnimation]);\r\n\r\n    //function to insert a value into the heap\r\n    const insert = () => {\r\n        if (!animating.current) {\r\n            var data = parseInt(insertInput.current.value);\r\n            if (isNaN(data))\r\n                data = randInt(-999, 1000);\r\n            insertInput.current.value = null;\r\n            heap.heap.push(data);\r\n            heap.pink = null;\r\n            heap.green = heap.heap.length - 1;\r\n            forceUpdate();\r\n            animationFunction.current = insertStep;\r\n            animationCurrent.current = heap.heap.length - 1;\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to do a single step of insertion animation\r\n    const insertStep = () => {\r\n        var parent = Math.floor((animationCurrent.current-1)/2);\r\n        if (parent < 0)\r\n            toggleAnimation();\r\n        else {\r\n            if (heap.heap[parent] > heap.heap[animationCurrent.current]) {\r\n                let temp = heap.heap[parent];\r\n                heap.heap[parent] = heap.heap[animationCurrent.current];\r\n                heap.heap[animationCurrent.current] = temp;\r\n                animationCurrent.current = parent;\r\n                heap.green = animationCurrent.current;\r\n            } else\r\n                toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to remove a value from the heap\r\n    const remove = () => {\r\n        if (!animating.current && heap.heap.length > 0) {\r\n            if (heap.heap.length === 1) {\r\n                heap.remove();\r\n                forceUpdate();\r\n            } else {\r\n                heap.green = null;\r\n                heap.pink = 0;\r\n                heap.focus = heap.heap.length-1;\r\n                forceUpdate();\r\n                animationFunction.current = removeStep;\r\n                animationCurrent.current = 0;\r\n                toggleAnimation();\r\n            }\r\n        }\r\n    }\r\n\r\n    //function to one step of remove animation\r\n    const removeStep = () => {\r\n        if (heap.focus !== null) {\r\n            heap.heap[0] = heap.heap.pop();\r\n            heap.focus = null;\r\n        } else {\r\n            if (2 * animationCurrent.current + 2 < heap.heap.length) {\r\n                if (heap.heap[animationCurrent.current] <= heap.heap[2 * animationCurrent.current + 1] && heap.heap[animationCurrent.current] <= heap.heap[2 * animationCurrent.current + 2]) {\r\n                    toggleAnimation();\r\n                } else if (heap.heap[2 * animationCurrent.current + 1] < heap.heap[2 * animationCurrent.current + 2]) {\r\n                    let temp = heap.heap[animationCurrent.current];\r\n                    heap.heap[animationCurrent.current] = heap.heap[2 * animationCurrent.current + 1];\r\n                    heap.heap[2 * animationCurrent.current + 1] = temp;\r\n                    animationCurrent.current = 2 * animationCurrent.current + 1;\r\n                    heap.pink = animationCurrent.current;\r\n                } else {\r\n                    let temp = heap.heap[animationCurrent.current];\r\n                    heap.heap[animationCurrent.current] = heap.heap[2 * animationCurrent.current + 2];\r\n                    heap.heap[2 * animationCurrent.current + 2] = temp;\r\n                    animationCurrent.current = 2 * animationCurrent.current + 2;\r\n                    heap.pink = animationCurrent.current;\r\n                }\r\n            } else if (2 * animationCurrent.current + 1 < heap.heap.length) {\r\n                if (heap.heap[animationCurrent.current] > heap.heap[2 * animationCurrent.current + 1]) {\r\n                    let temp = heap.heap[animationCurrent.current];\r\n                    heap.heap[animationCurrent.current] = heap.heap[2 * animationCurrent.current + 1];\r\n                    heap.heap[2 * animationCurrent.current + 1] = temp;\r\n                    animationCurrent.current = 2 * animationCurrent.current + 1;\r\n                    heap.pink = animationCurrent.current;\r\n                } else {\r\n                    toggleAnimation();\r\n                }\r\n            } else {\r\n                toggleAnimation();\r\n            }\r\n        }\r\n    }\r\n\r\n    //changes the animation speed when the slider changes\r\n    const updateSpeed = () => {\r\n        if (animationFunction.current != null) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                animationFunction.current();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"binary-heap\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomHeap}>Random</button>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <input ref={insertInput} type=\"text\"></input>\r\n                <br />\r\n                <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                <br />\r\n                <span className=\"labeledSlider\">\r\n                    <label>Animation Speed</label>\r\n                    <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                </span>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <BinaryTreeDisplay tree={heap.getTree()} border={heap.focusNode} green={heap.greenNode} pink={heap.pinkNode} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinaryHeap;","import React from 'react';\r\n\r\nconst BinaryHeapInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A Binary Heap is special type of Binary Tree with a few special properties. The first property is that it is a complete tree. This means that every level in the tree is completely filled with nodes except the last level, where all of the nodes are as far left as possible. The second property is that any given node in the tree has a smaller or greater value than all of the nodes in its child sub-trees. In a Min Heap, the value will always be smaller than all of its children. In a Max Heap the value will always be larger than all of its children. Here we will be using a Min Heap.</p>\r\n            <br />\r\n            <p><u>A Binary Heap has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into the heap</li>\r\n                <li><b>Remove:</b> removes the element at the root of the heap</li>\r\n            </ul>\r\n            <br />\r\n            <p>In order to maintain the special properties of the heap, insertion and removal of elements must be done in a careful manner. For inserting a value, a new node is created at the left-most position in the lowest layer of the tree that is not yet filled. Then this new node is repeatedly compared with its parent. If its value is less than its parent, it must swap positions with its parent in order to maintain the second property of a heap. It repeats this process until the parent is less than the new node, or the new node becomes the root.</p>\r\n            <br />\r\n            <p>In a heap removal is only done from the root of the tree. Since all of the nodes in the left and right sub-trees of the root are greater than the root, the root will be the minimum value in the heap. When we remove the root, we replace it with the left-most bottom node in the tree to maintain the first property of a heap. Then we must repeatedly compare the new root with its children elements. If the new node is less than the two children nodes, then the second property of a heap is maintained, and we are done. If it is not less than the two children, it is swapped with the smaller of the two children, and the process repeats. It must swap with the smaller of the two children because that child will become the parent of the other child. Once the new node is smaller than both of its children, or it reaches the bottom of the tree, the removal process is finished.</p>\r\n            <br />\r\n            <p>Because a Binary Heap is a complete tree, it can be stored in the form of an array with each level stored consecutively from left to right. The root is stored at index 0, and any node at index i  has its two children at index 2*i+1 and index 2*i+2. The parent of any node at index i is the floor of (i-1)/2. The advantage of storing the tree in an array form is that we do not need extra memory to store pointers, and we do not have to deal with changing pointers when nodes are swapped.</p>\r\n            <br />\r\n            <p>The complexities of the operations in a Binary Heap are dependent on the height of the tree, h. Because it is a complete tree, the height will always be O(log n). For insertion, the worst-case scenario is that the new node has to move all the way up to the root of the tree. For removal, the worst-case is that the node swapped with the previous root has to move all the way back to the bottom of the tree. Both of these things will take O(h) comparisons, so both insertion and removal have a complexity of O(log n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Complexity</th></tr>\r\n                    <tr><td>Insert</td><td>O(log n)</td></tr>\r\n                    <tr><td>Remove</td><td>O(log n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinaryHeapInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './HashTable.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//class for a hash table with linear probing\r\nclass HashTableClass {\r\n    constructor (size, loadFactor) {\r\n        this.array = [];\r\n        for (let i = 0; i < size; i++)\r\n            this.array.push(null);\r\n        this.elements = 0;\r\n        this.size = size;\r\n        this.LOADFACTOR = loadFactor;\r\n    }\r\n\r\n    //hash function to return normal modulus results with + or - numbers (value % size)\r\n    hash (value) {\r\n        return ((value % this.size)+this.size)%this.size;\r\n    }\r\n\r\n    resize () {\r\n        let oldArray = this.array;\r\n        this.array = [];\r\n        this.elements = 0;\r\n        for (let i = 0; i < 2*this.size; i++)\r\n            this.array.push(null);\r\n        this.size = 2*this.size;\r\n        for (let i = 0; i < oldArray.length; i++)\r\n            if (oldArray[i] !== null)\r\n                this.insert(oldArray[i]);\r\n    }\r\n\r\n    insert (value) {\r\n        if ((this.elements+1)/this.size > this.LOADFACTOR)\r\n            this.resize();\r\n        let hashCode = this.hash(value);\r\n        while (this.array[hashCode] !== null) {\r\n            hashCode++;\r\n            if (hashCode === this.array.length)\r\n                hashCode = 0;\r\n        }\r\n        this.array[hashCode] = value;\r\n        this.elements++;\r\n        return hashCode;\r\n    }\r\n\r\n    remove (value) {\r\n        let hashCode = this.hash(value);\r\n        while (this.array[hashCode] !== value) {\r\n            hashCode++;\r\n            if (hashCode === this.array.length)\r\n                hashCode = 0;\r\n            if (this.array[hashCode] === null)\r\n                return null;\r\n        }\r\n        this.array[hashCode] = null;\r\n        this.elements--;\r\n        return hashCode;\r\n    }\r\n\r\n    find (value) {\r\n        let hashCode = this.hash(value);\r\n        while (this.array[hashCode] !== value) {\r\n            hashCode++;\r\n            if (hashCode === this.array.length)\r\n                hashCode = 0;\r\n            if (this.array[hashCode] === null)\r\n                return null;\r\n        }\r\n        return hashCode;\r\n    }\r\n}\r\n\r\n//react component to display a hashtable\r\nconst HashTableDisplay = (props) => {\r\n    return props.hashTable.array.map((value, index) => {\r\n        if (index === props.green) {\r\n            return (\r\n                <div key={index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={value} color=\"green\"></Element>\r\n                </div>\r\n            );\r\n        } else if (index === props.pink) {\r\n            return (\r\n                <div key={index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={value} color=\"pink\"></Element>\r\n                </div>\r\n            );\r\n        } else if (index === props.yellow) {\r\n            return (\r\n                <div key={index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={value} color=\"yellow\"></Element>\r\n                </div>\r\n            );\r\n        } else {\r\n            return (\r\n                <div key={index} className=\"labeledElement\">\r\n                    <label>{index}</label>\r\n                    <Element value={value}></Element>\r\n                </div>\r\n            );\r\n        }\r\n    });\r\n}\r\n\r\n//react component for hash table visualization\r\nconst HashTable = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [hashTable, setHashTable] = useState(new HashTableClass(10, 0.5));\r\n    const randomSize = useRef();\r\n    const randomLF = useRef();\r\n    const buildSize = useRef();\r\n    const buildLF = useRef();\r\n    const insertInput = useRef();\r\n    const removeInput = useRef();\r\n    const findInput = useRef();\r\n    const lastInserted = useRef();\r\n    const lastRemoved = useRef();\r\n    const lastFound = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to create a random hashTable\r\n    const randomHashTable = () => {\r\n        lastInserted.current = null;\r\n        lastRemoved.current = null;\r\n        lastFound.current = null;\r\n        var size = parseInt(randomSize.current.value);\r\n        randomSize.current.value = null;\r\n        if (isNaN(size) || size < 1)\r\n            size = randInt(20, 100);\r\n        var loadFactor = parseFloat(randomLF.current.value);\r\n        randomLF.current.value = null;\r\n        if(isNaN(loadFactor) || loadFactor > 1.0 || loadFactor <= 0.0)\r\n            loadFactor = Math.random() * 0.5 + 0.25;\r\n        const newHashTable = new HashTableClass(size, loadFactor);\r\n        for (let i = 0; i < (size*loadFactor-1)*(Math.random()*0.75+0.25); i++)\r\n            newHashTable.insert(randInt(-999,1000));\r\n        setHashTable(newHashTable);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize to a random hash table\r\n    useEffect(randomHashTable, []);\r\n\r\n    //function to build an empty hash table\r\n    const build = () => {\r\n        lastInserted.current = null;\r\n        lastRemoved.current = null;\r\n        lastFound.current = null;\r\n        var size = parseInt(buildSize.current.value);\r\n        buildSize.current.value = null;\r\n        if (isNaN(size) || size < 1)\r\n            size = randInt(20, 100);\r\n        var loadFactor = parseFloat(buildLF.current.value);\r\n        buildLF.current.value = null;\r\n        if(isNaN(loadFactor) || loadFactor > 1.0 || loadFactor <= 0.0)\r\n            loadFactor = Math.random() * 0.5 + 0.25;\r\n        setHashTable(new HashTableClass(size, loadFactor));\r\n    }\r\n\r\n    //function to insert into hash table\r\n    const insert = () => {\r\n        lastInserted.current = null;\r\n        lastRemoved.current = null;\r\n        lastFound.current = null;\r\n        var data = parseInt(insertInput.current.value);\r\n        if (isNaN(data))\r\n            data = randInt(-999,1000);\r\n        lastInserted.current = hashTable.insert(data);\r\n        forceUpdate();\r\n        insertInput.current.value = null;\r\n    }\r\n\r\n    //function to remove from hash table\r\n    const remove = () => {\r\n        lastInserted.current = null;\r\n        lastRemoved.current = null;\r\n        lastFound.current = null;\r\n        var data = parseInt(removeInput.current.value);\r\n        if (!isNaN(data))\r\n            lastRemoved.current = hashTable.remove(data);\r\n        forceUpdate();\r\n        removeInput.current.value = null;\r\n    }\r\n\r\n    //function to find a value in the hash table\r\n    const find = () => {\r\n        lastInserted.current = null;\r\n        lastRemoved.current = null;\r\n        lastFound.current = null;\r\n        var data = parseInt(findInput.current.value);\r\n        if (!isNaN(data))\r\n            lastFound.current = hashTable.find(data);\r\n        forceUpdate();\r\n        findInput.current.value = null;\r\n    }\r\n\r\n    return (\r\n        <div className=\"hash-table\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={randomHashTable}>Rand</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Size</label>\r\n                        <input id=\"randomSizeInput\" ref={randomSize} type=\"text\"></input>\r\n                    </span>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Load Factor</label>\r\n                        <input id=\"randomLFInput\" ref={randomLF} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"buildButton\" onClick={build}>Build</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Size</label>\r\n                        <input id=\"buildSizeInput\" ref={buildSize} type=\"text\"></input>\r\n                    </span>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Load Factor</label>\r\n                        <input id=\"buildLFInput\" ref={buildLF} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                    <input id=\"insertInput\" ref={insertInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                    <input id=\"removeInput\" ref={removeInput} type=\"text\"></input>\r\n                    <br />\r\n                    <button id=\"findButton\" onClick={find}>Find</button>\r\n                    <input id=\"findInput\" ref={findInput} type=\"text\"></input>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <HashTableDisplay hashTable={hashTable} green={lastInserted.current} pink={lastRemoved.current} yellow={lastFound.current} />\r\n                    <p>Current Load Factor: {(hashTable.elements / hashTable.size).toFixed(2)} / {(hashTable.LOADFACTOR).toFixed(2)}</p>\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Last Inserted</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Last Removed</p>\r\n                <br />\r\n                <Element color=\"yellow\"></Element>\r\n                <p>= Last Found</p>\r\n            </div>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nexport default HashTable;","import React from 'react';\r\n\r\nconst HashTableInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A Hash Table is a data structure that places values in an array at an index based on a hash code computed from the key using a hash function. In this visualization, the key and the value are the same integer value. An array is defined for the Hash Table with a fixed size. Once the array reaches a certain capacity of elements, a new larger array is created and all of the previous elements are inserted back into the new array. The maximum capacity of the array before it must be resized is called the load factor, and is typically a fixed percentage.</p>\r\n            <br />\r\n            <p><u>A Hash Table has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Build:</b> initializes a hash table with a given size and load factor</li>\r\n                <li><b>Insert:</b> inserts a value into the hash table with a certain key</li>\r\n                <li><b>Remove:</b> removes the value for a given key from the hash table</li>\r\n                <li><b>Find:</b> checks if a given key is in the hash table and returns its value</li>\r\n            </ul>\r\n            <br />\r\n            <p>In an ideal situation, the hash function will provide a unique index for every key provided to it. However, it is possible to have two different keys that produce the same hash code. This is called a collision and can be handled in many different ways. One way to handle it is linear probing. This means that if a value is already located at the computed index when inserting a key and value, we perform a linear scan of the array to find the next open position, and insert the key and value there.</p>\r\n            <br />\r\n            <p>A key and value can be removed from the hash table similar to insertion. First the hash code is computed, then that index is checked for the given key and value. If it is not a linear scan is performed to find the target. If an empty slot is found in the linear scan, it means that key is not in the hash table and the scan ends. If the key and value are found, they are removed. Finding the value for a key can be done in exactly the same way, except the value is returned instead of deleting the key value pair.</p>\r\n            <br />\r\n            <p>Because the ideal position of elements can be computed in constant time for a Hash Table, most of its operations have an average-case complexity of O(1). However because of collisions and the potential need to resize the array of a hash table, the worst-case complexity of most operations is O(n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Worst-Case</th><th>Average-Case</th></tr>\r\n                    <tr><td>Build</td><td>O(1)</td><td>O(1)</td></tr>\r\n                    <tr><td>Insert</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Remove</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Find</td><td>O(n)</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default HashTableInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Set.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//react component to display a set\r\nconst SetDisplay = (props) => {\r\n    var componentList = [];\r\n    componentList.push(<p className=\"curly-brace\" key={-1}>&#123;</p>);\r\n    componentList = componentList.concat([...props.set].map((value, index) => {\r\n        return <Element key={index} value={value}></Element>;\r\n    }));\r\n    componentList.push(<p className=\"curly-brace\" key={componentList.length}>&#125;</p>);\r\n    return componentList;\r\n}\r\n\r\n//react component for set visualization\r\nconst MySet = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [set, setSet] = useState(new Set());\r\n    const insertInput = useRef();\r\n    const removeInput = useRef();\r\n    const findInput = useRef();\r\n    const findOutput = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to create a random set\r\n    const randomSet = () => {\r\n        const size = randInt(20, 100);\r\n        const newSet = new Set();\r\n        for (let i = 0; i < size; i++)\r\n            newSet.add(randInt(-999,1000));\r\n        setSet(newSet);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //function to create an empty set\r\n    const emptySet = () => {\r\n        setSet(new Set());\r\n    }\r\n\r\n    //initialize to a random set\r\n    useEffect(randomSet, []);\r\n\r\n    //function to insert into set\r\n    const insert = () => {\r\n        var data = parseInt(insertInput.current.value);\r\n        if (isNaN(data))\r\n            data = randInt(-999,1000);\r\n        set.add(data);\r\n        forceUpdate();\r\n        insertInput.current.value = null;\r\n    }\r\n\r\n    //function to remove from set\r\n    const remove = () => {\r\n        var data = parseInt(removeInput.current.value);\r\n        if (!isNaN(data))\r\n            set.delete(data);\r\n        forceUpdate();\r\n        removeInput.current.value = null;\r\n    }\r\n\r\n    //function to find a value in the set\r\n    const find = () => {\r\n        var data = parseInt(findInput.current.value);\r\n        if (!isNaN(data)) {\r\n            if (set.has(data))\r\n                findOutput.current.value = data + \" is in set\"\r\n            else\r\n                findOutput.current.value = data + \" not in set\"\r\n        }\r\n        forceUpdate();\r\n        findInput.current.value = null;\r\n    }\r\n\r\n    return (\r\n        <div className=\"set\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomSet}>Random</button>\r\n                <br />\r\n                <button id=\"emptyButton\" onClick={emptySet}>Empty</button>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <input id=\"insertInput\" ref={insertInput} type=\"text\"></input>\r\n                <br />\r\n                <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                <input id=\"removeInput\" ref={removeInput} type=\"text\"></input>\r\n                <br />\r\n                <button id=\"findButton\" onClick={find}>Find</button>\r\n                <input id=\"findInput\" ref={findInput} type=\"text\"></input>\r\n                <br />\r\n                <input id=\"findOutput\" ref={findOutput} type=\"text\" readOnly></input>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <SetDisplay set={set} />\r\n            </div>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nexport default MySet;","import React from 'react';\r\n\r\nconst SetInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A set is an Abstract Data Type (ADT) representing an unordered collection of data with no repeat elements. The data is stored in no particular order, and there can only be one of any given value in the set. Elements are either in or not in the set. There is no concept of order or quantities in a set. Thus sets are most useful for problems in which membership in the set is the most important property.</p>\r\n            <br />\r\n            <p><u>A Set has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> attempts to add an element to the set</li>\r\n                <li><b>Remove:</b> attempts to remove an element from the set</li>\r\n                <li><b>Find:</b> checks if an element is in the set</li>\r\n            </ul>\r\n            <br />\r\n            <p>The Set ADT is typically implemented using a Hash Table. With the hash table implementation, the key used for any value in the set is the same as its value. Because a Hash Table has constant time complexities for insertion, removal, and finding operations, a set has the same complexities for these operations.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Worst-Case</th><th>Average-Case</th></tr>\r\n                    <tr><td>Insert</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Remove</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Find</td><td>O(n)</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SetInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Map.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//react component to display a map\r\nconst MapDisplay = (props) => {\r\n    var componentList = [];\r\n    props.map.forEach((value, key) => {\r\n        componentList.push(\r\n            <div key={componentList.length} className=\"map-pair\">\r\n                <Element value={key} />\r\n                <br />\r\n                <p className=\"map-arrow\">&#x2193;</p>\r\n                <br />\r\n                <Element value={value} color=\"green\" />\r\n            </div>\r\n        );\r\n    });\r\n    return componentList;\r\n}\r\n\r\n//react component for map visualization\r\nconst MyMap = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [map, setMap] = useState(new Map());\r\n    const insertKey = useRef();\r\n    const insertValue = useRef();\r\n    const removeKey = useRef();\r\n    const getKey = useRef();\r\n    const getOutput = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to create a random map\r\n    const randomMap = () => {\r\n        const size = randInt(5, 40);\r\n        const newMap = new Map();\r\n        for (let i = 0; i < size; i++)\r\n            newMap.set(randInt(-999,1000), randInt(-999,1000));\r\n        setMap(newMap);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //function to create an empty map\r\n    const emptyMap = () => {\r\n        setMap(new Map());\r\n    }\r\n\r\n    //initialize to a random map\r\n    useEffect(randomMap, []);\r\n\r\n    //function to insert into map\r\n    const insert = () => {\r\n        var key = parseInt(insertKey.current.value);\r\n        if (isNaN(key))\r\n            key = randInt(-999,1000);\r\n        var value = parseInt(insertValue.current.value);\r\n        if (isNaN(value))\r\n            value = randInt(-999,1000);\r\n        map.set(key, value);\r\n        forceUpdate();\r\n        insertKey.current.value = null;\r\n        insertValue.current.value = null;\r\n    }\r\n\r\n    //function to remove from map\r\n    const remove = () => {\r\n        var key = parseInt(removeKey.current.value);\r\n        if (!isNaN(key))\r\n            map.delete(key);\r\n        forceUpdate();\r\n        removeKey.current.value = null;\r\n    }\r\n\r\n    //function to get a value for a key in a map\r\n    const get = () => {\r\n        var key = parseInt(getKey.current.value);\r\n        if (!isNaN(key))\r\n            getOutput.current.value = map.get(key);\r\n        forceUpdate();\r\n        getKey.current.value = null;\r\n    }\r\n\r\n    return (\r\n        <div className=\"map\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={randomMap}>Random</button>\r\n                <br />\r\n                <button id=\"emptyButton\" onClick={emptyMap}>Empty</button>\r\n                <br />\r\n                <button id=\"insertButton\" onClick={insert}>Insert</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Key</label>\r\n                    <input id=\"insertKey\" ref={insertKey} type=\"text\"></input>\r\n                </span>\r\n                <span className=\"labeledInput\">\r\n                    <label>Value</label>\r\n                    <input id=\"insertValue\" ref={insertValue} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"removeButton\" onClick={remove}>Remove</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Key</label>\r\n                    <input id=\"removeKey\" ref={removeKey} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"getButton\" onClick={get}>Get</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Key</label>\r\n                    <input id=\"getKey\" ref={getKey} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <input id=\"getOutput\" ref={getOutput} type=\"text\" readonly></input>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <MapDisplay map={map} />\r\n            </div>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nexport default MyMap;","import React from 'react';\r\n\r\nconst MapInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>A Map is an Abstract Data Type (ADT) representing a collection of key and value pairs. Any value in the Map can be accessed using its corresponding key. Keys in a map must be unique, meaning each key can only have one corresponding value. The key value pairs in a map are stored in no particular order, they are simply a collection of data.</p>\r\n            <br />\r\n            <p><u>A Map has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> adds a new key and value pair to the map or sets a new value for a key</li>\r\n                <li><b>Remove:</b> attempts to remove a key and value pair from the map</li>\r\n                <li><b>Get:</b> attempts to return the value in the map for a given key</li>\r\n            </ul>\r\n            <br />\r\n            <p>The Map ADT is typically implemented using a Hash Table. A Hash Table is a natural choice to implement a Map because it already has key and value pairs. Because a Hash Table has constant time complexities for insertion, removal, and get operations, a map has the same complexities for these operations.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Operation</th><th>Worst-Case</th><th>Average-Case</th></tr>\r\n                    <tr><td>Insert</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Remove</td><td>O(n)</td><td>O(1)</td></tr>\r\n                    <tr><td>Get</td><td>O(n)</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MapInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './InsertionSort.scss';\r\nimport Element from '../Element/Element';\r\n\r\n\r\nconst InsertionSortDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index === props.currentCompare && index === props.currentInserting)\r\n            return <Element key={index} value={value} color=\"yellow\" border=\"bordered\" />\r\n\r\n        if (index === props.currentCompare)\r\n            return <Element key={index} value={value} color=\"green\" border=\"bordered\" />\r\n\r\n        if (index === props.currentInserting)\r\n            return <Element key={index} value={value} color=\"yellow\" />\r\n\r\n        if (index < props.sortedEndIndex)\r\n            return <Element key={index} value={value} color=\"green\" />\r\n\r\n        return <Element key={index} value={value} />\r\n    });\r\n}\r\n\r\nconst InsertionSort = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const [sorted, setSorted] = useState(false);\r\n    const sorting = useRef(false);\r\n    const interval = useRef(null);\r\n    const sortedEndIndex = useRef(-1);\r\n    const currentInserting = useRef(-1);\r\n    const currentCompare = useRef(-1);\r\n    const toggleSortingButton = useRef();\r\n    const generateArrayButton = useRef();\r\n    const arraySizeInput = useRef();\r\n    const speedSlider = useRef();\r\n\r\n\r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,50);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n            setSorted(false);\r\n            sortedEndIndex.current = -1;\r\n            currentInserting.current = -1;\r\n            currentCompare.current = -1;\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max - min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,50)));\r\n    }, [randomArray]);\r\n\r\n    //completes one step of the sorting algorithm\r\n    const sortingStep = () => {\r\n        \r\n        if (sortedEndIndex.current >= array.length) {\r\n            setSorted(true);\r\n            toggleSorting();\r\n            currentCompare.current = -1;\r\n            currentInserting.current = -1;\r\n        }\r\n        //if found lower element, insert current after that, restart process\r\n        else if (array[currentCompare.current] < array[currentInserting.current]) {\r\n            let temp = array[currentInserting.current];\r\n            for (let i = currentInserting.current - 1; i > currentCompare.current; i--) {\r\n                array[i + 1] = array[i];\r\n            }\r\n            array[currentCompare.current + 1] = temp;\r\n            currentInserting.current++;\r\n            currentCompare.current = currentInserting.current;\r\n            sortedEndIndex.current++;\r\n        }\r\n        //if at end of sorted and none lower found, insert at beginning, restart process\r\n        else if (currentCompare.current === 0) {\r\n            let temp = array[currentInserting.current];\r\n            for (let i = currentInserting.current - 1; i >= currentCompare.current; i--) {\r\n                array[i + 1] = array[i];\r\n            }\r\n            array[currentCompare.current] = temp;\r\n            currentInserting.current++;\r\n            currentCompare.current = currentInserting.current;\r\n            sortedEndIndex.current++;\r\n        }\r\n        else if (currentInserting.current === -1) {\r\n            currentInserting.current++;\r\n            sortedEndIndex.current = 1;\r\n            currentCompare.current = currentInserting.current;\r\n        }\r\n        else {\r\n            currentCompare.current--;\r\n        }\r\n\r\n    }\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        } else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div className=\"insertion-sort\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" ref={generateArrayButton} onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"toggleSortingButton\" className=\"greenButton\" ref={toggleSortingButton} onClick={toggleSorting}>Sort</button>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <InsertionSortDisplay array={array} sortedEndIndex={sortedEndIndex.current} currentInserting={currentInserting.current} currentCompare={currentCompare.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Sorted</p>\r\n                < br />\r\n                <Element></Element>\r\n                <p>= Unsorted</p>\r\n                <br />\r\n                <Element color=\"yellow\"></Element>\r\n                <p>= Current Element to be Inserted</p>\r\n                <br />\r\n                <Element color=\"green\" border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n        );\r\n}\r\n\r\nexport default InsertionSort;","import React from 'react';\r\n\r\nconst InsertionSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Insertion sort is an algorithm used to sort an array by partitioning an array into two subarrays: sorted and unsorted. It then builds the sorted subarray one element at a time until the unsorted subarray is depleted.</p>\r\n            <br />\r\n            <p>The algorithm repeatedly designates a value from the unsorted subarray as the current value to be inserted. It then iterates through the sorted array, comparing each element to the one to be inserted. Once the sorted position of the element to be inserted is determined, it is moved from the unsorted subarray into its proper sorted position in the sorted subarray. This process of designating the element to be inserted, finding its sorted position, and inserting it repeats until the unsorted subarray has been completely depleted and the whole starting list has been sorted.</p>\r\n            <br />\r\n            <p>Although the algorithm does become signicantly less efficient when used on large data sets, it is quite effiecient for sorting lists that are already mostly sorted. This, in conjunction with the ease of implementation, makes it an ideal sorting algorithm for many situtions. For example, a large sorted list which is constantly being added to.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Insertion Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n<sup>2</sup>)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default InsertionSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './SelectionSort.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst SelectionSortDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index < props.sortedEndIndex)\r\n            return <Element key={index} value={value} color=\"green\" />\r\n        if (index === props.currentMinimum && index === props.currentFocus)\r\n            return <Element key={index} value={value} color=\"pink\" border=\"bordered\" />\r\n        if (index === props.currentMinimum)\r\n            return <Element key={index} value={value} color=\"pink\" />\r\n        if (index === props.currentFocus)\r\n            return <Element key={index} value={value} border=\"bordered\" />\r\n        return <Element key={index} value={value} />\r\n    });\r\n}\r\n\r\nconst SelectionSort = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const [sorted, setSorted] = useState(false);\r\n    const sorting = useRef(false);\r\n    const interval = useRef(null);\r\n    const sortedEndIndex = useRef(0);\r\n    const currentFocus = useRef(-1);\r\n    const currentMinimum = useRef(-1);\r\n    const toggleSortingButton = useRef();\r\n    const arraySizeInput = useRef();\r\n    const speedSlider = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,50);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n            setSorted(false);\r\n            sortedEndIndex.current = 0;\r\n            currentFocus.current = -1;\r\n            currentMinimum.current = -1;\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,50)));\r\n    }, [randomArray]);\r\n\r\n    //completes one step of the sorting algorithm\r\n    const sortingStep = () => {\r\n        if (sortedEndIndex.current >= array.length) {\r\n            setSorted(true);\r\n            toggleSorting();\r\n            return;\r\n        }\r\n        if (currentFocus.current === array.length-1) {\r\n            var temp = array[sortedEndIndex.current];\r\n            array[sortedEndIndex.current] = array[currentMinimum.current];\r\n            array[currentMinimum.current] = temp;\r\n            sortedEndIndex.current += 1;\r\n            currentFocus.current = sortedEndIndex.current-1;\r\n            currentMinimum.current = -1;\r\n            return;\r\n        }\r\n        currentFocus.current += 1;\r\n        if (currentMinimum.current === -1) {\r\n            currentMinimum.current = currentFocus.current;\r\n        } else if (array[currentMinimum.current] > array[currentFocus.current]) {\r\n            currentMinimum.current = currentFocus.current;\r\n        }\r\n    }\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        } else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"selection-sort\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"toggleSortingButton\" className=\"greenButton\" ref={toggleSortingButton} onClick={toggleSorting}>Sort</button>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <SelectionSortDisplay array={array} sortedEndIndex={sortedEndIndex.current} currentFocus={currentFocus.current} currentMinimum={currentMinimum.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Sorted</p>\r\n                < br />\r\n                <Element></Element>\r\n                <p>= Unsorted</p>\r\n                <br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Current Minimum</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SelectionSort;","import React from 'react';\r\n\r\nconst SelectionSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Selection sort is an algorithm to sort an array that repeatedly finds the minimum value of the unsorted elements. Two subarrays are kept. At the beginning of the array is a subarray of elements that have been already been selected as the minimum and are placed in their correct position in the sorted array. The rest of the array is the remaining unsorted elements.</p>\r\n            <br />\r\n            <p>The algorithm repeatedly finds the minimum value of the unsorted subarray, and swaps it with the first element of the unsorted portion. That element is then considered sorted, so the sorted subarray grows in size, and the unsorted subarray decreases in size. This is repeated until the sorted portion of the array becomes as large as the entire array.</p>\r\n            <br />\r\n            <p>To find the minimum element of the unsorted subarray, a linear scan is used where the smallest element is kept track of. Then the minimum can be swapped with the beginning in costant time. The linear scan portion takes n comparisons the first time, n-1 comparisons the second time, and so on until there is 1 comparison on the last scan. Because of this the overall time complexity is O(n<sup>2</sup>). Since all of the swaps are done in place for selection sort, the space complexity is constant.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Selection Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n<sup>2</sup>)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SelectionSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './BubbleSort.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst BubbleSortDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index > props.sortedStart.current) {\r\n            return <Element key={index} value={value} color=\"green\"/>\r\n        }\r\n        if (index === props.focusOne.current || index === props.focusTwo.current) {\r\n            if (index === props.min.current) {\r\n                return <Element key={index} value={value} color=\"pink\" border=\"bordered\" />\r\n            }\r\n            if (index === props.max.current) {\r\n                return <Element key={index} value={value} color=\"yellow\" border=\"bordered\" />\r\n            }\r\n            else return <Element key={index} value={value} border=\"bordered\" />\r\n            \r\n        }\r\n        return <Element key={index} value={value} />\r\n    });\r\n}\r\n\r\n\r\n\r\nconst BubbleSort = () => {\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const [sorted, setSorted] = useState(false);\r\n    const sorting = useRef(false);\r\n    const interval = useRef(null);\r\n    const swappedOnPass = useRef(false);\r\n    const sortedStart = useRef(array.length - 1);\r\n    const focusOne = useRef(-1);\r\n    const focusTwo = useRef(-1);\r\n    const min = useRef(-1);\r\n    const max = useRef(-1);\r\n    const toggleSortingButton = useRef();\r\n    const generateArrayButton = useRef();\r\n    const arraySizeInput = useRef();\r\n    const speedSlider = useRef();\r\n    \r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,50);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n            setSorted(false);\r\n            sortedStart.current = size - 1;\r\n            focusOne.current = -1;\r\n            focusTwo.current = -1;\r\n            min.current = -1;\r\n            max.current = -1\r\n            //swappedOnPass.current = false;\r\n            //sorting.current = false;\r\n            //currentMinimum.current = -1;\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        sortedStart.current = size - 1;\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,50)));\r\n    }, [randomArray]);\r\n\r\n    function swap(arr, x, y) {\r\n        var temp = arr[x];\r\n        arr[x] = arr[y];\r\n        arr[y] = temp;\r\n    }\r\n\r\n    //completes one step of the sorting algorithm\r\n    const sortingStep = () => {\r\n        if (max.current === 1 && sortedStart.current === 1) {\r\n            sortedStart.current = -1;\r\n            return;\r\n        }\r\n\r\n        if (sortedStart.current <= 0) {\r\n            setSorted(true);\r\n            toggleSorting();\r\n            return;\r\n        }\r\n        if (focusOne.current === -1 && focusTwo.current === -1){\r\n            focusOne.current = 0;\r\n            focusTwo.current = 1;\r\n            return;\r\n        }\r\n        if (max.current >= sortedStart.current) {\r\n            if (swappedOnPass.current === false) {\r\n                sortedStart.current = -1;\r\n            }\r\n\r\n            min.current = -1;\r\n            max.current = -1;\r\n            focusOne.current = 0;\r\n            focusTwo.current = 1;\r\n            swappedOnPass.current = false;\r\n            sortedStart.current--;\r\n            \r\n        }\r\n        if (min.current === -1) {\r\n            if (array[focusOne.current] < array[focusTwo.current]) {\r\n                min.current = focusOne.current;\r\n                max.current = focusTwo.current;\r\n            }\r\n            else {\r\n                min.current = focusTwo.current;\r\n                max.current = focusOne.current;\r\n            }\r\n        }\r\n        else if (min.current > max.current) {\r\n            swap(array, min.current, max.current);\r\n            swappedOnPass.current = true;\r\n            var temp = max.current;\r\n            max.current = min.current;\r\n            min.current = temp;\r\n        } \r\n        else {\r\n            min.current = -1;\r\n            max.current = -1;\r\n            focusOne.current++;\r\n            focusTwo.current++;\r\n            \r\n        }\r\n        \r\n    }\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        }\r\n        else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"bubble-sort\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" ref={generateArrayButton} onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"toggleSortingButton\" className=\"greenButton\" ref={toggleSortingButton} onClick={toggleSorting}>Sort</button>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <BubbleSortDisplay array={array} sortedStart={sortedStart} focusOne={focusOne} focusTwo={focusTwo} min={min} max={max}/>\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Sorted</p>\r\n                < br />\r\n                <Element></Element>\r\n                <p>= Unsorted</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focuses</p>\r\n                <br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Lesser of Focuses</p>\r\n                <br />\r\n                <Element color=\"yellow\"></Element>\r\n                <p>= Greater of Focuses</p>\r\n            </div>\r\n        </div>);\r\n}\r\n\r\nexport default BubbleSort;","import React from 'react';\r\n\r\nconst BubbleSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Bubble sort is an algorithm used to sort an array by repeatedly iterating through each adjacent pair of elements in a list, comparing each element to its adjacent partner, and then either swapping or not swapping the elements such that they end up in the correct order. Upon reaching the end of the list, the algorithm repeats this process, starting over at the first element of the array. This process is repeated until each adjacent pair is observed to be in the correct order and no swaps take place for an entire pass.</p>\r\n            <br />\r\n            <p>The visualization below shows an optimized version of Bubble sort. This version involves recognizing that after n passes over the array, the nth element in the array is in the sorted position. Thus, the algorithm need not pass over the final n-1 elements after n passes. This reduces the total number of necessary comparisons, however makes no change to the number of swaps (since swaps only occur on elements which are in the incorrect position).</p>\r\n            <br />\r\n            <p>In both versions of Bubble sort, the maximum number of passes needed to sort an an array with n elements will be O(n). Since each pass will also take on average O(n) time, the overall time complexity of Bubble sort is O(n<sup>2</sup>). No extra space is needed for Bubble sort.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Bubble Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n<sup>2</sup>)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BubbleSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './MergeSort.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//react component to display merge sort arrays\r\nconst MergeSortDisplay = (props) => {\r\n    var componentList = [];\r\n    for (let i = 0; i < props.mergedArrays.length; i++) {\r\n        var array1 = props.arrays[2*i];\r\n        var array2 = [];\r\n        if (2*i+1 < props.arrays.length)\r\n            array2 = props.arrays[2*i+1];\r\n        componentList.push(<MergeSortDisplayRow key={componentList.length} array1={array1} array2={array2} mergedArray={props.mergedArrays[i]} />);\r\n        componentList.push(<hr key={componentList.length} />);\r\n    }\r\n    componentList.pop();\r\n    return componentList;\r\n}\r\n\r\n//react component to display a merge sort row consisting of 2 arrays, and the array it is merging into\r\nconst MergeSortDisplayRow = (props) => {\r\n    return (\r\n        <div className=\"merge-sort-display-row\">\r\n            <div>\r\n                <MergeSortDisplayRowHelper1 array1={props.array1} array2={props.array2} />\r\n            </div>\r\n            <div>\r\n                <MergeSortDisplayRowHelper2 array={props.mergedArray} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\nconst MergeSortDisplayRowHelper1 = (props) => {\r\n    var componentList = [];\r\n    for (let i = 0; i < props.array1.length; i++) {\r\n        if (i === props.array1.length-1)\r\n            componentList.push(<Element key={componentList.length} value={props.array1[i]} border=\"bordered\" />);\r\n        else\r\n            componentList.push(<Element key={componentList.length} value={props.array1[i]} />);\r\n    }\r\n    if (props.array1.length === 0)\r\n        componentList.push(<Element key={componentList.length} color=\"none\" />);\r\n    componentList.push(<br key={componentList.length} />);\r\n    for (let i = 0; i < props.array2.length; i++) {\r\n        if (i === props.array2.length-1)\r\n            componentList.push(<Element key={componentList.length} value={props.array2[i]} border=\"bordered\" />);\r\n        else\r\n            componentList.push(<Element key={componentList.length} value={props.array2[i]} />);\r\n    }\r\n    if (props.array2.length === 0)\r\n        componentList.push(<Element key={componentList.length} color=\"none\" />);\r\n    return componentList;\r\n}\r\nconst MergeSortDisplayRowHelper2 = (props) => {\r\n    var componentList = [];\r\n    componentList.push(<p className=\"arrow\" key={0}>&#x2192;</p>);\r\n    for (let i = 0; i < props.array.length; i++)\r\n        if (props.array[i] !== null)\r\n            componentList.push(<Element key={componentList.length} color=\"green\" value={props.array[i]} />);\r\n    return componentList;\r\n}\r\n\r\n//react component for merge sort\r\nconst MergeSort = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const arrays = useRef([[]]);\r\n    const mergedArrays = useRef([[]]);\r\n    const mergedArraysCurrs = useRef([]);\r\n    const mergeRowIndex = useRef(0);\r\n    const [sorted, setSorted] = useState(false);\r\n    const sorting = useRef(false);\r\n    const interval = useRef(null);\r\n    const arraySizeInput = useRef();\r\n    const toggleSortingButton = useRef();\r\n    const speedSlider = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArrays = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,20);\r\n        if (size > 0) {\r\n            arrays.current = randomArrays(size);\r\n            initializeMergedArrays();\r\n            forceUpdate();\r\n            setSorted(false);\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArrays = useCallback((size) => {\r\n        var newArrays = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArrays[i] = [randInt(-999, 1000)];\r\n            }\r\n        return newArrays;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the arrays randomly\r\n    useEffect(() => {\r\n        arrays.current = randomArrays(randInt(5,20));\r\n        initializeMergedArrays();\r\n        forceUpdate();\r\n    }, [randomArrays]);\r\n\r\n    //function to initialize list of empty arrays to be merged into\r\n    const initializeMergedArrays = () => {\r\n        mergedArrays.current = [];\r\n        mergedArraysCurrs.current = [];\r\n        mergeRowIndex.current = 0;\r\n        const length = Math.ceil(arrays.current.length/2);\r\n        for (let i = 0; i < length; i++) {\r\n            mergedArrays.current.push([]);\r\n            if (2*i+1 < arrays.current.length) {\r\n                for (let j = 0; j < arrays.current[2*i].length+arrays.current[2*i+1].length; j++)\r\n                    mergedArrays.current[i].push(null);\r\n                mergedArraysCurrs.current.push(arrays.current[2*i].length+arrays.current[2*i+1].length-1);\r\n            } else {\r\n                for (let j = 0; j < arrays.current[2*i].length; j++)\r\n                    mergedArrays.current[i].push(null);\r\n                mergedArraysCurrs.current.push(arrays.current[2*i].length-1);\r\n            }\r\n        }\r\n    }\r\n\r\n    //function to do a single step of merge sorting\r\n    const sortingStep = () => {\r\n        //get the two arrays we are currently merging\r\n        var array1 = arrays.current[2 * mergeRowIndex.current];\r\n        var array2 = [];\r\n        if (2 * mergeRowIndex.current + 1 < arrays.current.length)\r\n            array2 = arrays.current[2 * mergeRowIndex.current + 1];\r\n        //if both arrays are empty increase the current mergeRowIndex\r\n        if (array1.length === 0 && array2.length === 0)\r\n            mergeRowIndex.current++;\r\n            //if done with merging all rows then move mergedArrays into main arrays\r\n            if (mergeRowIndex.current > mergedArrays.current.length-1) {\r\n                if (mergedArrays.current.length === 1) {\r\n                    setSorted(true);\r\n                    clearInterval(interval.current);\r\n                    sorting.current = false;\r\n                    toggleSortingButton.current.innerHTML = \"Sort\";\r\n                    toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n                    toggleSortingButton.current.classList.add(\"greenButton\");\r\n                    return;\r\n                }\r\n                arrays.current = mergedArrays.current;\r\n                initializeMergedArrays();\r\n                return;\r\n            }\r\n            //get the two arrays we are currently merging\r\n            array1 = arrays.current[2 * mergeRowIndex.current];\r\n            array2 = [];\r\n            if (2 * mergeRowIndex.current + 1 < arrays.current.length)\r\n                array2 = arrays.current[2 * mergeRowIndex.current + 1];\r\n            //if either array is empty concatenate the other to the merged array\r\n            if (array1.length === 0) {\r\n                for (let i = array2.length-1; i >= 0; i--) {\r\n                    mergedArrays.current[mergeRowIndex.current][mergedArraysCurrs.current[mergeRowIndex.current]] = array2[i];\r\n                    mergedArraysCurrs.current[mergeRowIndex.current]--;\r\n                }\r\n                arrays.current[2*mergeRowIndex.current+1] = [];\r\n            } else if (array2.length === 0) {\r\n                for (let i = array1.length-1; i >= 0; i--) {\r\n                    mergedArrays.current[mergeRowIndex.current][mergedArraysCurrs.current[mergeRowIndex.current]] = array1[i];\r\n                    mergedArraysCurrs.current[mergeRowIndex.current]--;\r\n                }\r\n                arrays.current[2*mergeRowIndex.current] = [];\r\n            //add the max of the last elements to the merged array\r\n            } else {\r\n                if (array1[array1.length-1] >= array2[array2.length-1]) {\r\n                    mergedArrays.current[mergeRowIndex.current][mergedArraysCurrs.current[mergeRowIndex.current]] = array1[array1.length-1];\r\n                    mergedArraysCurrs.current[mergeRowIndex.current]--;\r\n                    arrays.current[2*mergeRowIndex.current].pop();\r\n                } else {\r\n                    mergedArrays.current[mergeRowIndex.current][mergedArraysCurrs.current[mergeRowIndex.current]] = array2[array2.length-1];\r\n                    mergedArraysCurrs.current[mergeRowIndex.current]--;\r\n                    arrays.current[2*mergeRowIndex.current+1].pop();\r\n                }\r\n            }\r\n    }\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        } else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"merge-sort\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={generateArrays}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Array Size</label>\r\n                    <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button ref={toggleSortingButton} className=\"greenButton\" onClick={toggleSorting}>Sort</button>\r\n                <br />\r\n                <span className=\"labeledSlider\">\r\n                    <label>Animation Speed</label>\r\n                    <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                </span>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <MergeSortDisplay arrays={arrays.current} mergedArrays={mergedArrays.current} />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MergeSort;","import React from 'react';\r\n\r\nconst MergeSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Merge Sort is a divide and conquer algorithm for sorting an array. First the array is split up into several sub-arrays of size 1. Then every pair of arrays is merged in such a way that the new merged array contains the elements of the two previous arrays in sorted order. This is repeated until all arrays have been merged into one final sorted array.</p>\r\n            <br />\r\n            <p>Another way to think of Merge Sort is as a recursive algorithm. First the array is split into two parts, then both parts are recursively sorted, and finally the two parts are merged back together in a sorted order. The base case of this recursion would be a sub-array of size 1, which is already sorted.</p>\r\n            <br />\r\n            <p>The way that two sorted sub-arrays can be merged into one sorted array is fairly simple. We just repeatedly take the larger of the two elements at the ends of both arrays, and add that to our new merged array. This continues until one sub-array is empty, and then we just concatenate the remaining values at the beginning of our new array. This works because the maximum value of the two values at the ends of the sub-arrays is guaranteed to be the largest value remaining in all of the two sub-arrays.</p>\r\n            <br />\r\n            <p>To understand the complexity of Merge Sort, consider the complexity of a single level of the algorithm, and how many levels there will be. A single level of Merge Sort consists of merging k pairs of sub-arrays with a total size n/k. Merging a pair of sub-arrays with a total size of n/k takes linear time with a worst case of n/k-1 comparisons. Doing this k times gives a single level of Merge Sort a complexity of k*O(n/k) which is just O(n). The number of levels of Merge Sort is equal to the number of times we can split our sub-arrays into two parts. This will be O(log n). So with O(log n) levels and O(n) time on each level, the overall time complexity of Merge Sort is O(n log n). The space required for Merge Sort is just memory for the new arrays that are being merged into which will be O(n) in total.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Merge Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n log n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MergeSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './QuickSort.scss';\r\nimport Element from '../Element/Element';\r\n\r\nconst QuickSortDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index === props.pivot.current)\r\n            return <Element key={index} value={value} color=\"purple\" />\r\n        if (index === props.low.current && index === props.high.current)\r\n            return <Element key={index} value={value} border=\"bordered\" color=\"yellow\" />\r\n        if (index === props.low.current)\r\n            return <Element key={index} value={value} border=\"bordered\" color=\"pink\" />\r\n        if (index === props.high.current)\r\n            return <Element key={index} value={value} border=\"bordered\" color=\"green\" />\r\n        if (props.sortedElements.current.includes(index))\r\n            return <Element key={index} value={value} color=\"green\" />\r\n        else return <Element key={index} value={value} />\r\n    });\r\n}\r\n\r\n\r\nconst QuickSort = () => {\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const interval = useRef(null);\r\n    const sorting = useRef(false);\r\n    const [sorted, setSorted] = useState(false);\r\n    const toggleSortingButton = useRef();\r\n    const generateArrayButton = useRef();\r\n    const arraySizeInput = useRef();\r\n    const speedSlider = useRef();\r\n\r\n    const sortedElements = useRef([]);\r\n    const worklist = useRef([]);\r\n    const low = useRef(-1);\r\n    const high = useRef(-1);\r\n    const pivot = useRef(-1);\r\n\r\n\r\n    //We call update on fake state variable to force rerender\r\n    const forceUpdate = () => {\r\n        forceRender(renders => renders + 1);\r\n    }\r\n\r\n    function swap(arr, x, y) {\r\n        var temp = arr[x];\r\n        arr[x] = arr[y];\r\n        arr[y] = temp;\r\n    }\r\n\r\n    function buildSorted(size) {\r\n        var arr = [];\r\n        for (var i = 0; i < size; i++) {\r\n            arr.push(i);\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    const sortingStep = () => {\r\n        if (sortedElements.current.length === array.length) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        }\r\n\r\n        \r\n        if (array.length === 1) {\r\n            sortedElements.current.push(0);\r\n        }\r\n        if (pivot.current === -1) {\r\n            //initial step\r\n            if (sortedElements.current.length === 0) {\r\n                pivot.current = array.length - 1;\r\n                low.current = 0;\r\n                high.current = array.length - 2;\r\n            }\r\n            else {\r\n                low.current = worklist.current.shift();\r\n                pivot.current = worklist.current.shift();\r\n                if (!sortedElements.current.includes(pivot.current - 1)) high.current = pivot.current - 1;\r\n\r\n                if (pivot.current === 0) {\r\n                    sortedElements.current.push(pivot.current);\r\n                    low.current = -1;\r\n                    pivot.current = -1;\r\n                    high.current = -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (pivot.current === 0) {\r\n                sortedElements.current.push(pivot.current);\r\n            }\r\n            else if (low.current > high.current) {\r\n                var toInsert = array[pivot.current];\r\n                array.splice(pivot.current, 1);\r\n                array.splice(low.current, 0, toInsert);\r\n                sortedElements.current.push(low.current);\r\n                //worklist.current = worklist.current.map((value, index) => {\r\n                //    if (value > low.current) return value + 1;\r\n                //    else return;\r\n                //})\r\n\r\n                if (low.current !== 0) {\r\n                    //find low partition\r\n                    let temp = sortedElements.current.filter(n => n < low.current);\r\n                    \r\n                    if (temp.length === 0) {\r\n\r\n\r\n                        \r\n                        worklist.current.push(0);\r\n                        worklist.current.push(low.current - 1);\r\n                    }\r\n                    else {\r\n                        if (Math.max(...temp) !== low.current - 1) {\r\n                            worklist.current.push(Math.max(...temp) + 1);\r\n                            worklist.current.push(low.current - 1);\r\n                        }\r\n                    }\r\n                }\r\n                //find high bound\r\n                if (low.current !== array.length - 1) {\r\n                    let temp = sortedElements.current.filter(n => n > low.current);\r\n                    if (temp.length === 0) {\r\n                        worklist.current.push(low.current + 1);\r\n                        worklist.current.push(array.length - 1);\r\n                    }\r\n                    else {\r\n                        if (Math.min(...temp) !== low.current + 1) {\r\n                            worklist.current.push(low.current + 1);\r\n                            worklist.current.push(Math.min(...temp) - 1);\r\n                        }\r\n                    }\r\n\r\n                    \r\n                }\r\n\r\n                low.current = -1;\r\n                pivot.current = -1;\r\n                high.current = -1;\r\n\r\n            }\r\n            else if (array[low.current] > array[pivot.current]) {\r\n                if (array[high.current] < array[pivot.current]) {\r\n                    swap(array, low.current, high.current);\r\n                }\r\n                else high.current--;\r\n            }\r\n            else low.current++;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        } else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n\r\n    const genWorstCase = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if (isNaN(size))\r\n            size = randInt(5, 50);\r\n        if (size > 0) {\r\n            setArray(buildSorted(size));\r\n            setSorted(false);\r\n\r\n            pivot.current = -1;\r\n            low.current = -1;\r\n            high.current = -1;\r\n            sortedElements.current = [];\r\n\r\n        }\r\n\r\n        arraySizeInput.current.value = null;\r\n        \r\n    }\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if (isNaN(size))\r\n            size = randInt(5, 50);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n            setSorted(false);\r\n\r\n            pivot.current = -1;\r\n            low.current = -1;\r\n            high.current = -1;\r\n            sortedElements.current = [];\r\n            \r\n        }\r\n        \r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n        for (let i = 0; i < size; i++) {\r\n            newArray[i] = randInt(-999, 1000);\r\n        }\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max - min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5, 50)));\r\n    }, [randomArray]);\r\n\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000 - speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div className=\"quick-sort\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" ref={generateArrayButton} onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"worstButton\" onClick={genWorstCase}>Worst-case</button>\r\n                    <br />\r\n                    <button id=\"toggleSortingButton\" className=\"greenButton\" ref={toggleSortingButton} onClick={toggleSorting}>Sort</button>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <QuickSortDisplay array={array} low={low} high={high} pivot={pivot} sortedElements={sortedElements} />\r\n                </div>\r\n                \r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Sorted</p>\r\n                < br />\r\n                <Element></Element>\r\n                <p>= Unsorted</p>\r\n                <br />\r\n                <Element color=\"pink\" border=\"bordered\"></Element>\r\n                <p>= Current Low</p>\r\n                <br />\r\n                <Element color=\"green\" border=\"bordered\"></Element>\r\n                <p>= Current High</p>\r\n                <br />\r\n                <Element color=\"purple\" ></Element>\r\n                <p>= Pivot</p>\r\n            </div>\r\n        </div>\r\n        );\r\n}\r\n\r\n\r\n\r\n\r\nexport default QuickSort;","import React from 'react';\r\n\r\nconst QuickSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Quick sort is a divide-and-conquer algorithm to sort an array. It involves first selecting a pivot and then swapping elements and moving the pivot such that all elements to the left of the pivot are less than the pivot and all elements to the right of the pivot are greater. The greater and less than values are then partitioned into two subarrays and the process is repeated recursiveley.</p>\r\n            <br />\r\n            <p>The choice of the pivot is open to some variation. In this visualization we chose to use the last element in each partition as the pivot. Thus, a single partition is processed by first designating the last element in the partition as the pivot. Next, a low pointer is placed on the lower bound index of the partition and a high pointer is placed on the higher bound index of the parition. The low pointer then moves rightward until and element is found that is greater than the pivot element. The high pointer follows suit by moving leftward until it finds an element that is less than the pivot element. When both the low and high pointers find their target they perform a swap. The pointers then both move again, repeating the process, until they cross. Crossed pointers indicate the sorted location of the pivot element. Thus, the pivot is moved to that location and the array is partitioned into a lower and upper subarray. The entire procedure is then repeated recursively until all elements are sorted.</p>\r\n            <br />\r\n            <p>Quick sort has a worst-case time complexity of O(n<sup>2</sup>). This occurs when partitions are repeatedly the most unbalanced they can be, meaning that after every partitioning process one of the new paritions is of size n-1 elements. In our visualization this would occur when the array is already sorted prior to the use of our algorithm. In the best-case, all partitions created of nearly equal sizes, and the time-complexity is O(n log n). The average case is also O(n log n).</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Quick Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Average-case Time Complexity</td><td>O(n log n)</td></tr>\r\n                    <tr><td>Worst-case Time Complexity</td><td>O(n<sup>2</sup>)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default QuickSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './HeapSort.scss';\r\nimport Element from '../Element/Element.js';\r\nimport { BinaryHeapClass } from '../BinaryHeap/BinaryHeap.js';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay.js';\r\n\r\n//react component to dislplay an aray\r\nconst ArrayDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        return <Element key={index} value={value} />\r\n    });\r\n}\r\nconst SortedArrayDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        return <Element key={index} value={value} color=\"green\" />\r\n    });\r\n}\r\n\r\n//main react component for heap sort animation\r\nconst HeapSort = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [heap, setHeap] = useState(new BinaryHeapClass());\r\n    const [array, setArray] = useState([]);\r\n    const [sortedArray, setSortedArray] = useState([]);\r\n    const [sorted, setSorted] = useState(false);\r\n    const arraySizeInput = useRef();\r\n    const toggleSortingButton = useRef();\r\n    const speedSlider = useRef();\r\n    const sorting = useRef(false);\r\n    const interval = useRef(null);\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (sorting.current) {\r\n            toggleSorting();\r\n        }\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,32);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n            setHeap(new BinaryHeapClass());\r\n            setSortedArray([]);\r\n            setSorted(false);\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,32)));\r\n    }, [randomArray]);\r\n\r\n    //function to do a single step of sorting animation\r\n    const sortingStep = () => {\r\n        if(array.length === 0 && heap.heap.length === 0) {\r\n            setSorted(true);\r\n            toggleSorting();\r\n        } else if(array.length !== 0)\r\n            heap.insert(array.pop())\r\n        else\r\n            sortedArray.push(heap.remove());\r\n    }\r\n\r\n    //function to turn sorting on and off by button click\r\n    const toggleSorting = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            sorting.current = false;\r\n            toggleSortingButton.current.innerHTML = \"Sort\";\r\n            toggleSortingButton.current.classList.remove(\"pinkButton\");\r\n            toggleSortingButton.current.classList.add(\"greenButton\");\r\n        } else if (!sorted) {\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            sorting.current = true;\r\n            toggleSortingButton.current.innerHTML = \"Stop\";\r\n            toggleSortingButton.current.classList.remove(\"greenButton\");\r\n            toggleSortingButton.current.classList.add(\"pinkButton\");\r\n        }\r\n    }\r\n    //changes the animation speed of sorting when the slider changes\r\n    const updateSpeed = () => {\r\n        if (sorting.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                sortingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"heap-sort\">\r\n            <div className=\"controls\">\r\n                <button id=\"randomButton\" onClick={generateArray}>Random</button>\r\n                <span className=\"labeledInput\">\r\n                    <label>Array Size</label>\r\n                    <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                </span>\r\n                <br />\r\n                <button id=\"toggleSortingButton\" className=\"greenButton\" ref={toggleSortingButton} onClick={toggleSorting}>Sort</button>\r\n                <br />\r\n                <span className=\"labeledSlider\">\r\n                    <label>Animation Speed</label>\r\n                    <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                </span>\r\n            </div>\r\n            <div className=\"visualization\">\r\n                <div className=\"array\">\r\n                    <ArrayDisplay array={array} />\r\n                </div>\r\n                <BinaryTreeDisplay tree={heap.getTree()} />\r\n                <div className=\"array\">\r\n                    <SortedArrayDisplay array={sortedArray} />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default HeapSort;","import React from 'react';\r\n\r\nconst HeapSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Heap Sort is an algorithm to sort an array which adds all of the elements to a Binary Heap, and then repeatedly removes elements from the heap until it is empty. The elements are removed from the heap in a sorted order, and are added to a new sorted array in the order that they are removed.</p>\r\n            <br />\r\n            <p>In order to sort the elements in our array from least to greatest, the heap we use must be a Min Heap. This way the element at the root of the tree is guaranteed to be the smallest value in the heap. We repeatedly remove from the root to get the smallest remaining value in the tree. Once the heap is empty, all of the original elements have been removed in a sorted order.</p>\r\n            <br />\r\n            <p>Insertion and removal into a Binary Heap both have a time complexity of O(log n). Because every element in the array must be both inserted and removed from the heap, the overall time complexity of Heap Sort is n*O(log n) + n*O(log n), which is O(n log n). The space required to store all of the values in a Binary Heap will be linear with regards to the number of elements in the original array. However, it is possible to convert the original array into a Binary Heap in place, and vice versa. Thus, the space complexity of Heap Sort can be constant.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Heap Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n log n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default HeapSortInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './LinearSearch.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//react component to display a linear search array\r\nconst ArrayDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index === props.focus)\r\n            return <Element key={index} value={value} border=\"bordered\" />;\r\n        else if (index === props.green)\r\n            return <Element key={index} value={value} color=\"green\" />;\r\n        else if (index === props.pink)\r\n            return <Element key={index} value={value} color=\"pink\" />;\r\n        else\r\n            return <Element key={index} value={value} />;\r\n    });\r\n}\r\n\r\n//react component for linear search\r\nconst LinearSearch = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const arraySizeInput = useRef();\r\n    const searchInput = useRef();\r\n    const speedSlider = useRef();\r\n    const searching = useRef();\r\n    const searchValue = useRef(null);\r\n    const focus = useRef(null);\r\n    const interval = useRef();\r\n    const green = useRef();\r\n    const pink = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (searching.current) {\r\n            toggleAnimation();\r\n        }\r\n        focus.current = null;\r\n        green.current = null;\r\n        pink.current = null;\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,50);\r\n        if (size > 0) {\r\n            setArray(randomArray(size));\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,50)));\r\n    }, [randomArray]);\r\n\r\n    //function to start searching animation\r\n    const search = () => {\r\n        if (searching.current)\r\n            toggleAnimation();\r\n        var data = parseInt(searchInput.current.value);\r\n        if (isNaN(data))\r\n            data = 0;\r\n        searchInput.current.value = null;\r\n        searchValue.current = data;\r\n        toggleAnimation();\r\n        focus.current = 0;\r\n        forceUpdate();\r\n    }\r\n\r\n    //function to 1 step of searching animation\r\n    const searchingStep = () => {\r\n        if (array[focus.current] === searchValue.current) {\r\n            green.current = focus.current;\r\n            focus.current = null;\r\n            toggleAnimation();\r\n        } else if (focus.current === array.length-1) {\r\n            pink.current = array.length-1;\r\n            focus.current = null;\r\n            toggleAnimation();\r\n        } else {\r\n            focus.current++;\r\n        }\r\n    }\r\n\r\n    //function to turn searching on and off by button click\r\n    const toggleAnimation = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            searching.current = false;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            searching.current = true;\r\n            focus.current = null;\r\n            green.current = null;\r\n            pink.current = null;\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of searching when the slider changes\r\n    const updateSpeed = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"linear-search\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"searchButton\" onClick={search}>Search</button>\r\n                    <input id=\"searchInput\" ref={searchInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <ArrayDisplay array={array} focus={focus.current} green={green.current} pink={pink.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Element Found</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Element Not Found</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default LinearSearch;","import React from 'react';\r\n\r\nconst LinearSearchInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Linear Search is an algorithm to search for a value in an array or any other linear data structure. It takes the straightforward approach of starting at the beginning of the array, and searching every element one by one from the beginning to the end. If it finds the target value or reaches the end of the array, the search is over.</p>\r\n            <br />\r\n            <p>In the worst-case, Linear Search must compare the target value with every value in the array. Thus, an array with n elements will have a time complexity of O(n) for Linear Search. The space complexity of linear search is constant because no extra space is required.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Linear Search</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default LinearSearchInformation;","import React, { useState, useRef, useEffect, useCallback } from 'react';\r\nimport './BinarySearch.scss';\r\nimport Element from '../Element/Element';\r\n\r\n//react component to display a linear search array\r\nconst ArrayDisplay = (props) => {\r\n    return props.array.map((value, index) => {\r\n        if (index === props.focus)\r\n            return <Element key={index} value={value} border=\"bordered\" />;\r\n        else if (index === props.green)\r\n            return <Element key={index} value={value} color=\"green\" />;\r\n        else if (index > props.upper || index < props.lower)\r\n            return <Element key={index} value={value} color=\"pink\" />;\r\n        else\r\n            return <Element key={index} value={value} />;\r\n    });\r\n}\r\n\r\n//react component for linear search\r\nconst BinarySearch = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [array, setArray] = useState([]);\r\n    const arraySizeInput = useRef();\r\n    const searchInput = useRef();\r\n    const speedSlider = useRef();\r\n    const searching = useRef();\r\n    const searchValue = useRef(null);\r\n    const focus = useRef(null);\r\n    const interval = useRef();\r\n    const green = useRef();\r\n    const lower = useRef();\r\n    const upper = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //sets state array to a random array for sorting\r\n    const generateArray = () => {\r\n        if (searching.current) {\r\n            toggleAnimation();\r\n        }\r\n        focus.current = null;\r\n        green.current = null;\r\n        var size = parseInt(arraySizeInput.current.value);\r\n        if(isNaN(size))\r\n            size = randInt(5,50);\r\n        if (size > 0) {\r\n            lower.current = 0;\r\n            upper.current = size-1;\r\n            setArray(randomArray(size));\r\n        }\r\n        arraySizeInput.current.value = null;\r\n    }\r\n    //generates a random array within reasonable bounds\r\n    const randomArray = useCallback((size) => {\r\n        var newArray = new Array(size);\r\n            for (let i = 0; i < size; i++) {\r\n                newArray[i] = randInt(-999, 1000);\r\n            }\r\n        newArray.sort((x,y) => {return x-y});\r\n        return newArray;\r\n    }, []);\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize the array randomly at start\r\n    useEffect(() => {\r\n        setArray(randomArray(randInt(5,50)));\r\n    }, [randomArray]);\r\n\r\n    //function to start searching animation\r\n    const search = () => {\r\n        if (searching.current)\r\n            toggleAnimation();\r\n        var data = parseInt(searchInput.current.value);\r\n        if (isNaN(data))\r\n            data = 0;\r\n        searchInput.current.value = null;\r\n        searchValue.current = data;\r\n        toggleAnimation();\r\n        focus.current = Math.floor((lower.current+upper.current)/2);\r\n        forceUpdate();\r\n    }\r\n\r\n    //function to 1 step of searching animation\r\n    const searchingStep = () => {\r\n        if (upper.current < lower.current) {\r\n            focus.current = null;\r\n            toggleAnimation();\r\n        } else if (focus.current > upper.current || focus.current < lower.current) {\r\n            focus.current = Math.floor((lower.current+upper.current)/2);\r\n        } else if (array[focus.current] < searchValue.current) {\r\n            lower.current = focus.current+1;\r\n        } else if (array[focus.current] > searchValue.current) {\r\n            upper.current = focus.current-1;\r\n        } else {\r\n            green.current = focus.current;\r\n            focus.current = null;\r\n            toggleAnimation();\r\n        }\r\n    }\r\n\r\n    //function to turn searching on and off by button click\r\n    const toggleAnimation = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            searching.current = false;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            searching.current = true;\r\n            focus.current = null;\r\n            green.current = null;\r\n            lower.current = 0;\r\n            upper.current = array.length-1;\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of searching when the slider changes\r\n    const updateSpeed = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"binary-search\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={generateArray}>Random</button>\r\n                    <span className=\"labeledInput\">\r\n                        <label>Array Size</label>\r\n                        <input id=\"arraySizeInput\" ref={arraySizeInput} type=\"text\"></input>\r\n                    </span>\r\n                    <br />\r\n                    <button id=\"searchButton\" onClick={search}>Search</button>\r\n                    <input id=\"searchInput\" ref={searchInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <ArrayDisplay array={array} focus={focus.current} green={green.current} lower={lower.current} upper={upper.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Element Found</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Elements Ruled Out</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default BinarySearch;","import React from 'react';\r\n\r\nconst BinarySearchInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Binary Search is an algorithm to search for a value in an array or any other linear data structure. Binary Search is only possible if the array is already in a sorted order. The search starts at the midpoint of the array, and compares it with the target value. If it is less than the target value, the search continues only in the right half of the array. If it is greater than the target value, the search continues only in the left half of the array. If it is equal, the search ends and we have found our target value. The number of elements we are searching is cut in half with every comparison this way. Once we are down to a single element and it is not equal to our target then our search is over.</p>\r\n            <br />\r\n            <p>Binary Search relies on the fact that the array is already sorted beforehand. Because of this it is able to eliminate half of the entries remaining with every comparison, because all values after a certain value are greater than or equal to that value, and all values before a certain value are less than or equal to that value.</p>\r\n            <br />\r\n            <p>Because the number of elements we are looking at gets cut in half with every comparison, the total number of comparisons needed to complete Binary Search in an array of length n will be maximum log n. Thus the time complexity of Binary Search is O(log n). The only extra memory we need for Binary Search is two pointers representing the start and end of the section of the array we are still considering. Therefore the space complexity of Binary Search is constant.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Binary Search</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(log n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinarySearchInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './DepthFirstSearch.scss';\r\nimport { BinaryTreeNode, BinaryTreeClass } from '../BinaryTree/BinaryTree.js';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay';\r\nimport Element from '../Element/Element';\r\n\r\nconst DepthFirstSearch = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [tree, setTree] = useState(new BinaryTreeClass(null));\r\n    const nodeQueue = useRef([]);\r\n    const index = useRef();\r\n    const searchInput = useRef();\r\n    const speedSlider = useRef();\r\n    const searching = useRef();\r\n    const searchValue = useRef(null);\r\n    const current = useRef(null);\r\n    const interval = useRef();\r\n    const green = useRef();\r\n    const pink = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to generate random tree\r\n    const randomTree = () => {\r\n        var newNodeChance = 0.9;\r\n        const levels = randInt(1,5);\r\n        var newTree = new BinaryTreeClass(new BinaryTreeNode(randInt(-999,1000)));\r\n        var nodes = [newTree.root];\r\n        var newNodes = [];\r\n        for (let level = 0; level < levels; level++) {\r\n            for (let i = 0; i < nodes.length; i++) {\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].left = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].left);\r\n                }\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].right = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].right);\r\n                }\r\n            }\r\n            nodes = newNodes;\r\n            newNodes = [];\r\n        }\r\n        setTree(newTree);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize tree to a random tree\r\n    useEffect(randomTree, []);\r\n\r\n    //function to add nodes to queue in DFS order\r\n    const dfs = (node) => {\r\n        if (node !== null) {\r\n            nodeQueue.current.push(node);\r\n            dfs(node.left);\r\n            dfs(node.right);\r\n        }\r\n\r\n    }\r\n\r\n    //function to start searching animation\r\n    const search = () => {\r\n        if (searching.current)\r\n            toggleAnimation();\r\n        var data = parseInt(searchInput.current.value);\r\n        if (isNaN(data))\r\n            data = 0;\r\n        searchInput.current.value = null;\r\n        nodeQueue.current = [];\r\n        dfs(tree.root);\r\n        current.current = nodeQueue.current[0];\r\n        index.current = 0;\r\n        searchValue.current = data;\r\n        toggleAnimation();\r\n        forceUpdate();\r\n    }\r\n\r\n    //function to 1 step of searching animation\r\n    const searchingStep = () => {\r\n        if (current.current.value === searchValue.current) {\r\n            green.current = current.current;\r\n            current.current = null;\r\n            toggleAnimation();\r\n        } else if (index.current === nodeQueue.current.length-1) {\r\n            pink.current = current.current;\r\n            current.current = null;\r\n            toggleAnimation();\r\n        } else {\r\n            index.current++;\r\n            current.current = nodeQueue.current[index.current];\r\n        }\r\n    }\r\n\r\n    //function to turn searching on and off by button click\r\n    const toggleAnimation = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            searching.current = false;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            searching.current = true;\r\n            green.current = null;\r\n            pink.current = null;\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of searching when the slider changes\r\n    const updateSpeed = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"depth-first-search\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={randomTree}>Random</button>\r\n                    <br />\r\n                    <button id=\"searchButton\" onClick={search}>Search</button>\r\n                    <input id=\"searchInput\" ref={searchInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <BinaryTreeDisplay tree={tree} border={current.current} green={green.current} pink={pink.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Element Found</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Element Not Found</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default DepthFirstSearch;","import React from 'react';\r\n\r\nconst DepthFirstSearchInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Depth First Search (DFS) is an algorithm to search for a value in a tree data structure. Every node is traversed in a certain order until either the value is found, or every node in the tree has been visited meaning the value is not in the tree.</p>\r\n            <br />\r\n            <p>In a Depth First Search, we start searching at the root of the tree. The root of the tree becomes our current node. We first check if the current node contains our target value. Then we recursively check all of the children sub-trees of the current node. For a binary tree, this means we recursively check the entire left sub-tree of the current node and the entire right sub-tree. In this way we first check all the way down the left-most path down the tree, and then backtrack when there are no more nodes left on that branch, and continue until every node has been visited.</p>\r\n            <br />\r\n            <p>For any tree with n nodes, the DFS algorithm will have a time complexity of O(n). This is because in the worst-case it will visit every node in the tree once, and compare its value with the target value. The space complexity of DFS is constant because it requires no extra space.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Depth First Search</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default DepthFirstSearchInformation;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './BreadthFirstSearch.scss';\r\nimport { BinaryTreeNode, BinaryTreeClass } from '../BinaryTree/BinaryTree.js';\r\nimport BinaryTreeDisplay from '../BinaryTree/BinaryTreeDisplay';\r\nimport Element from '../Element/Element';\r\n\r\nconst BreadthFirstSearch = () => {\r\n\r\n    const [, forceRender] = useState(0);\r\n    const [tree, setTree] = useState(new BinaryTreeClass(null));\r\n    const nodeQueue = useRef([]);\r\n    const index = useRef();\r\n    const searchInput = useRef();\r\n    const speedSlider = useRef();\r\n    const searching = useRef();\r\n    const searchValue = useRef(null);\r\n    const current = useRef(null);\r\n    const interval = useRef();\r\n    const green = useRef();\r\n    const pink = useRef();\r\n\r\n    //We call update on fake state variable to force rerender\r\n\tconst forceUpdate = () => {\r\n\t\tforceRender(renders => renders+1);\r\n\t}\r\n\r\n    //function to generate random tree\r\n    const randomTree = () => {\r\n        var newNodeChance = 0.9;\r\n        const levels = randInt(1,5);\r\n        var newTree = new BinaryTreeClass(new BinaryTreeNode(randInt(-999,1000)));\r\n        var nodes = [newTree.root];\r\n        var newNodes = [];\r\n        for (let level = 0; level < levels; level++) {\r\n            for (let i = 0; i < nodes.length; i++) {\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].left = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].left);\r\n                }\r\n                if (Math.random() < Math.pow(newNodeChance, level)) {\r\n                    nodes[i].right = new BinaryTreeNode(randInt(-999,1000));\r\n                    newNodes.push(nodes[i].right);\r\n                }\r\n            }\r\n            nodes = newNodes;\r\n            newNodes = [];\r\n        }\r\n        setTree(newTree);\r\n    }\r\n    const randInt = (min, max) => {\r\n        return Math.floor(Math.random() * (max-min) + min);\r\n    }\r\n\r\n    //initialize tree to a random tree\r\n    useEffect(randomTree, []);\r\n\r\n    //function to add nodes to queue in DFS order\r\n    const bfs = () => {\r\n        var currQueue = [tree.root];\r\n        var nextQueue = [];\r\n        while (currQueue.length !== 0) {\r\n            for (let i = 0; i < currQueue.length; i++) {\r\n                nodeQueue.current.push(currQueue[i]);\r\n                if (currQueue[i].left !== null)\r\n                    nextQueue.push(currQueue[i].left);\r\n                if (currQueue[i].right !== null)\r\n                    nextQueue.push(currQueue[i].right);\r\n            }\r\n            currQueue = nextQueue;\r\n            nextQueue = [];\r\n        }\r\n    }\r\n\r\n    //function to start searching animation\r\n    const search = () => {\r\n        if (searching.current)\r\n            toggleAnimation();\r\n        var data = parseInt(searchInput.current.value);\r\n        if (isNaN(data))\r\n            data = 0;\r\n        searchInput.current.value = null;\r\n        nodeQueue.current = [];\r\n        bfs();\r\n        current.current = nodeQueue.current[0];\r\n        index.current = 0;\r\n        searchValue.current = data;\r\n        toggleAnimation();\r\n        forceUpdate();\r\n    }\r\n\r\n    //function to 1 step of searching animation\r\n    const searchingStep = () => {\r\n        if (current.current.value === searchValue.current) {\r\n            green.current = current.current;\r\n            current.current = null;\r\n            toggleAnimation();\r\n        } else if (index.current === nodeQueue.current.length-1) {\r\n            pink.current = current.current;\r\n            current.current = null;\r\n            toggleAnimation();\r\n        } else {\r\n            index.current++;\r\n            current.current = nodeQueue.current[index.current];\r\n        }\r\n    }\r\n\r\n    //function to turn searching on and off by button click\r\n    const toggleAnimation = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            searching.current = false;\r\n        } else {\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n            searching.current = true;\r\n            green.current = null;\r\n            pink.current = null;\r\n        }\r\n    }\r\n\r\n    //changes the animation speed of searching when the slider changes\r\n    const updateSpeed = () => {\r\n        if (searching.current) {\r\n            clearInterval(interval.current);\r\n            interval.current = setInterval(() => {\r\n                searchingStep();\r\n                forceUpdate();\r\n            }, 1000-speedSlider.current.value);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"breadth-first-search\">\r\n            <div id=\"main\">\r\n                <div className=\"controls\">\r\n                    <button id=\"randomButton\" onClick={randomTree}>Random</button>\r\n                    <br />\r\n                    <button id=\"searchButton\" onClick={search}>Search</button>\r\n                    <input id=\"searchInput\" ref={searchInput} type=\"text\"></input>\r\n                    <br />\r\n                    <span className=\"labeledSlider\">\r\n                        <label>Animation Speed</label>\r\n                        <input className=\"slider\" ref={speedSlider} onChange={updateSpeed} min=\"0\" max=\"990\" type=\"range\"></input>\r\n                    </span>\r\n                </div>\r\n                <div className=\"visualization\">\r\n                    <BinaryTreeDisplay tree={tree} border={current.current} green={green.current} pink={pink.current} />\r\n                </div>\r\n            </div>\r\n            <div className=\"legend\">\r\n                <Element color=\"green\"></Element>\r\n                <p>= Element Found</p>\r\n                < br />\r\n                <Element color=\"pink\"></Element>\r\n                <p>= Element Not Found</p>\r\n                <br />\r\n                <Element border=\"bordered\"></Element>\r\n                <p>= Current Focus</p>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default BreadthFirstSearch;","import React from 'react';\r\n\r\nconst BreadthFirstSearchInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <p>Breadth First Search (BFS) is an algorithm to search for a value in a tree data structure. Every node is traversed in a certain order until either the value is found, or every node in the tree has been visited meaning the value is not in the tree.</p>\r\n            <br />\r\n            <p>In a Breadth First Search, we start searching at the root of the tree. We then traverse down the tree level by level, checking every node in each level from left to right. The way that this is typically implemented is using a queue. First we start by adding the root to our queue. Then we dequeue the root from the queue, check if it was our target value, and then enqueue all of its children into the queue. We repeat this with every element that we dequeue from the queue until we find our target value, or the queue is empty. If the queue is empty and we have not found our target value then it means that value is not in the tree.</p>\r\n            <br />\r\n            <p>For any tree with n nodes, the BFS algorithm will have a time complexity of O(n). This is because in the worst-case it will visit every node in the tree once, and compare its value with the target value. The space complexity of BFS is O(n), because in the worst case all of the nodes of the tree besides the root will be on a single level, and they must all be stored in the queue.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Depth First Search</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(n)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BreadthFirstSearchInformation;","import React from 'react';\r\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\r\nimport './App.scss';\r\nimport Navigation from './Navigation/Navigation';\r\nimport Array from './Array/Array';\r\nimport ArrayInformation from './Array/ArrayInformation';\r\nimport List from './List/List';\r\nimport ListInformation from './List/ListInformation';\r\nimport ArrayList from './ArrayList/ArrayList';\r\nimport ArrayListInformation from './ArrayList/ArrayListInformation';\r\nimport LinkedList from './LinkedList/LinkedList';\r\nimport LinkedListInformation from './LinkedList/LinkedListInformation';\r\nimport Stack from './Stack/Stack';\r\nimport StackInformation from './Stack/StackInformation';\r\nimport Queue from './Queue/Queue';\r\nimport QueueInformation from './Queue/QueueInformation';\r\nimport BinaryTree from './BinaryTree/BinaryTree';\r\nimport BinaryTreeInformation from './BinaryTree/BinaryTreeInformation';\r\nimport BinarySearchTree from './BinarySearchTree/BinarySearchTree';\r\nimport BinarySearchTreeInformation from './BinarySearchTree/BinarySearchTreeInformation';\r\nimport AvlTree from './AvlTree/AvlTree';\r\nimport AvlTreeInformation from './AvlTree/AvlTreeInformation';\r\nimport BinaryHeap from './BinaryHeap/BinaryHeap';\r\nimport BinaryHeapInformation from './BinaryHeap/BinaryHeapInformation';\r\nimport HashTable from './HashTable/HashTable';\r\nimport HashTableInformation from './HashTable/HashTableInformation';\r\nimport Set from './Set/Set';\r\nimport SetInformation from './Set/SetInformation';\r\nimport Map from './Map/Map';\r\nimport MapInformation from './Map/MapInformation';\r\nimport InsertionSort from './InsertionSort/InsertionSort';\r\nimport InsertionSortInformation from './InsertionSort/InsertionSortInformation';\r\nimport SelectionSort from './SelectionSort/SelectionSort';\r\nimport SelectionSortInformation from './SelectionSort/SelectionSortInformation';\r\nimport BubbleSort from './BubbleSort/BubbleSort';\r\nimport BubbleSortInformation from './BubbleSort/BubbleSortInformation';\r\nimport MergeSort from './MergeSort/MergeSort';\r\nimport MergeSortInformation from './MergeSort/MergeSortInformation';\r\nimport QuickSort from './QuickSort/QuickSort';\r\nimport QuickSortInformation from './QuickSort/QuickSortInformation';\r\nimport HeapSort from './HeapSort/HeapSort';\r\nimport HeapSortInformation from './HeapSort/HeapSortInformation';\r\nimport LinearSearch from './LinearSearch/LinearSearch';\r\nimport LinearSearchInformation from './LinearSearch/LinearSearchInformation';\r\nimport BinarySearch from './BinarySearch/BinarySearch';\r\nimport BinarySearchInformation from './BinarySearch/BinarySearchInformation';\r\nimport DepthFirstSearch from './DepthFirstSearch/DepthFirstSearch';\r\nimport DepthFirstSearchInformation from './DepthFirstSearch/DepthFirstSearchInformation';\r\nimport BreadthFirstSearch from './BreadthFirstSearch/BreadthFirstSearch';\r\nimport BreadthFirstSearchInformation from './BreadthFirstSearch/BreadthFirstSearchInformation';\r\n\r\nconst App = () => {\r\n\t\treturn (\r\n\t\t\t<>\r\n\t\t\t\t<BrowserRouter>\r\n\t\t\t\t\t<header>DAILY DOSE OF DATA</header>\r\n\t\t\t\t\t<div className=\"main\">\r\n\t\t\t\t\t\t<Navigation />\r\n\t\t\t\t\t\t<div className=\"content\">\r\n\t\t\t\t\t\t\t<Switch>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/\">\r\n\t\t\t\t\t\t\t\t\t<div className=\"information\">\r\n\t\t\t\t\t\t\t\t\t\t<p>Home page</p>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Array\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Array</header>\r\n\t\t\t\t\t\t\t\t\t<Array />\r\n\t\t\t\t\t\t\t\t\t<ArrayInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/List\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">List</header>\r\n\t\t\t\t\t\t\t\t\t<List />\r\n\t\t\t\t\t\t\t\t\t<ListInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Array List\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Array List</header>\r\n\t\t\t\t\t\t\t\t\t<ArrayList />\r\n\t\t\t\t\t\t\t\t\t<ArrayListInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Linked List\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Linked List</header>\r\n\t\t\t\t\t\t\t\t\t<LinkedList />\r\n\t\t\t\t\t\t\t\t\t<LinkedListInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Stack\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Stack</header>\r\n\t\t\t\t\t\t\t\t\t<Stack />\r\n\t\t\t\t\t\t\t\t\t<StackInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Queue\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Queue</header>\r\n\t\t\t\t\t\t\t\t\t<Queue />\r\n\t\t\t\t\t\t\t\t\t<QueueInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Binary Tree\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Binary Tree</header>\r\n\t\t\t\t\t\t\t\t\t<BinaryTree />\r\n\t\t\t\t\t\t\t\t\t<BinaryTreeInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Binary Search Tree\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Binary Search Tree</header>\r\n\t\t\t\t\t\t\t\t\t<BinarySearchTree />\r\n\t\t\t\t\t\t\t\t\t<BinarySearchTreeInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Avl Tree\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">AVL Tree</header>\r\n\t\t\t\t\t\t\t\t\t<AvlTree />\r\n\t\t\t\t\t\t\t\t\t<AvlTreeInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Binary Heap\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Binary Heap</header>\r\n\t\t\t\t\t\t\t\t\t<BinaryHeap />\r\n\t\t\t\t\t\t\t\t\t<BinaryHeapInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Hash Table\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Hash Table</header>\r\n\t\t\t\t\t\t\t\t\t<HashTable />\r\n\t\t\t\t\t\t\t\t\t<HashTableInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Set\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Set</header>\r\n\t\t\t\t\t\t\t\t\t<Set />\r\n\t\t\t\t\t\t\t\t\t<SetInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Map\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Map</header>\r\n\t\t\t\t\t\t\t\t\t<Map />\r\n\t\t\t\t\t\t\t\t\t<MapInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Insertion Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Insertion Sort</header>\r\n\t\t\t\t\t\t\t\t\t<InsertionSort />\r\n\t\t\t\t\t\t\t\t\t<InsertionSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Selection Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Selection Sort</header>\r\n\t\t\t\t\t\t\t\t\t<SelectionSort />\r\n\t\t\t\t\t\t\t\t\t<SelectionSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Bubble Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Bubble Sort</header>\r\n\t\t\t\t\t\t\t\t\t<BubbleSort />\r\n\t\t\t\t\t\t\t\t\t<BubbleSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Merge Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Merge Sort</header>\r\n\t\t\t\t\t\t\t\t\t<MergeSort />\r\n\t\t\t\t\t\t\t\t\t<MergeSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Quick Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Quick Sort</header>\r\n\t\t\t\t\t\t\t\t\t<QuickSort />\r\n\t\t\t\t\t\t\t\t\t<QuickSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Heap Sort\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Heap Sort</header>\r\n\t\t\t\t\t\t\t\t\t<HeapSort />\r\n\t\t\t\t\t\t\t\t\t<HeapSortInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Linear Search\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Linear Search</header>\r\n\t\t\t\t\t\t\t\t\t<LinearSearch />\r\n\t\t\t\t\t\t\t\t\t<LinearSearchInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Binary Search\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Binary Search</header>\r\n\t\t\t\t\t\t\t\t\t<BinarySearch />\r\n\t\t\t\t\t\t\t\t\t<BinarySearchInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Depth First Search\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Depth First Search</header>\r\n\t\t\t\t\t\t\t\t\t<DepthFirstSearch />\r\n\t\t\t\t\t\t\t\t\t<DepthFirstSearchInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/Breadth First Search\">\r\n\t\t\t\t\t\t\t\t\t<header className=\"page-title\">Breadth First Search</header>\r\n\t\t\t\t\t\t\t\t\t<BreadthFirstSearch />\r\n\t\t\t\t\t\t\t\t\t<BreadthFirstSearchInformation />\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t\t<Route exact path=\"/about\">\r\n\t\t\t\t\t\t\t\t\t<div id=\"about-us\" className=\"information\">\r\n\t\t\t\t\t\t\t\t\t\t<h1>About Us</h1>\r\n\t\t\t\t\t\t\t\t\t\t<p>Thank you for visiting our website! We are two undergraduate college students studying in areas related to Computer Science. We decided to work together over an entire summer to bring to life this idea of a website to provide visualizations of various data structures and algorithms for educational purposes. We had little to no experience with web development before this, and we fully self-studied JavaScript, HTML, CSS, React.js, and Node.js, all of which were used to develop this website. This website is still a work in progress, and we plan to continue adding new content and features. Any feedback you would like to give us is appreciated, so feel free to contact us with the information below!</p>\r\n\t\t\t\t\t\t\t\t\t\t<hr />\r\n\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information\">\r\n\t\t\t\t\t\t\t\t\t\t\t<img src=\"quintenpicture.jpg\" alt=\"\"></img>\r\n\t\t\t\t\t\t\t\t\t\t\t<img src=\"stonybrooklogo.jpg\" alt=\"\"></img>\r\n\t\t\t\t\t\t\t\t\t\t\t<div id=\"quinten-information\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"information-header\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information-section\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Quinten De Man</b></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Stony Brook University</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Computer Science Honors</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Applied Mathematics and Statistics</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information-section\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Email:</b> quinten.deman@gmail.com</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>LinkedIn:</b> <a href=\"https://www.linkedin.com/in/quinten-de-man/\">https://www.linkedin.com/in/quinten-de-man/</a></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>GitHub:</b> <a href=\"https://github.com/quintendeman\">https://github.com/quintendeman</a></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"biography\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Biography</b></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Quinten is a rising junior at Stony Brook University with a double major in Computer Science and Applied Mathematics and Statistics. He has interests in Data Structures, Algorithms, Web Development, Machine Learning, and Artificial Intelligence. He has lots of experience with these topics from previous research experiences, work experiences, personal projects, and academic coursework. For more information visit his LinkedIn or GitHub pages.</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t<hr />\r\n\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information\">\r\n\t\t\t\t\t\t\t\t\t\t\t<img src=\"zackpicture.jpg\" alt=\"\"></img>\r\n\t\t\t\t\t\t\t\t\t\t\t<img src=\"northeasternlogo.png\" alt=\"\"></img>\r\n\t\t\t\t\t\t\t\t\t\t\t<div id=\"zack-information\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"information-header\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information-section\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Zackary Lassetter</b></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Northeastern University</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Northeastern National Merit Scholar</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Data Science and Economics</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"personal-information-section\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Email:</b> zackary@lassetter.org</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>LinkedIn:</b> <a href=\"https://www.linkedin.com/in/zackary-lassetter/\">https://www.linkedin.com/in/zackary-lassetter/</a></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>GitHub:</b> <a href=\"https://github.com/zlassetter\">https://github.com/zlassetter</a></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"biography\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p><b>Biography</b></p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<p>Zackary is a rising sophmore at Northeastern University and is currently pursing a combined major in Data Science and Economics. He is interested many topics across the field of computer science including Data Structures and Algorithms, but is also interested in the applications of these tools in the fields of Quantitative Finance, Econometrics, and Data Analytics. Please visit his LinkedIn and GitHub for more information.</p>\r\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t</Route>\r\n\t\t\t\t\t\t\t</Switch>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<footer>Made by Quinten De Man and Zackary Lassetter</footer>\r\n\t\t\t\t</BrowserRouter>\r\n\t\t\t</>\r\n\t\t);\r\n}\r\n\r\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}